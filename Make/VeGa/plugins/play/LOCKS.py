from pyrogram import Client, filters, enums
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ChatPermissions, Message, CallbackQuery
from pyrogram.enums import ChatMemberStatus, ChatType
import asyncio
import asyncio
from pyrogram import filters, enums, types
from pyrogram.errors import PeerIdInvalid, RPCError, FloodWait
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton

from VeGa import app
from datetime import datetime, timedelta
from VeGa import app
from config import OWNER_ID
import random
from random import choice
from pyrogram import Client, filters, enums
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ChatPermissions, Message, CallbackQuery
from pyrogram.enums import ChatMemberStatus, ChatType
import asyncio
from datetime import datetime, timedelta
from VeGa import app
from config import OWNER_ID
from config import*
import random
from random import choice
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery

from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery

from collections import defaultdict
import re
import requests
import asyncio
import glob
import os
import time
import requests
import random
import aiohttp
import wget
import yt_dlp
import traceback
from pyrogram.types import InputMediaAudio
import asyncio
import os
import re
from typing import Union

import yt_dlp
from yt_dlp import YoutubeDL
from pyrogram.enums import MessageEntityType
from pyrogram.types import Message
from youtubesearchpython.__future__ import VideosSearch

from VeGa.utils.database import is_on_off
from VeGa.utils.formatters import time_to_seconds
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from youtubesearchpython import SearchVideos
import requests
import wget
from config import *
import config
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from config import START_VIDS
from pyrogram import filters
from pyrogram import Client
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from random import  choice, randint
from pytube import Search
from pyrogram import Client, filters
from pyrogram.types import (InlineKeyboardButton,CallbackQuery,InlineKeyboardMarkup, Message)
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.errors import FloodWait, MessageNotModified
from pyrogram.types import Message
from youtube_search import YoutubeSearch
from youtubesearchpython import VideosSearch
from yt_dlp import YoutubeDL
from VeGa import app
import speech_recognition as sr
from pyrogram import Client, filters
from pydub import AudioSegment
from os import remove
import asyncio
import os
import time
import requests
import random
import aiohttp
from config import *
import config
from pyrogram import filters
from pyrogram import Client
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from telegraph import upload_file
from asyncio import gather
from random import  choice, randint
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import CallbackQuery, InputMediaPhoto, InlineKeyboardMarkup, InlineKeyboardButton
from pySmartDL import SmartDL
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube)
from pyrogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram import filters
import random
from pyrogram import Client

import requests
import yt_dlp
from youtube_search import YoutubeSearch

import asyncio
import config
import re
import os
import requests
from os import getenv
from pyrogram import Client, filters
from VeGa import app
from config import OWNER_ID
from pyrogram import filters, Client
from pyrogram import filters
from pyrogram import Client
from typing import Union
from aiohttp import ClientSession
from pyrogram import Client, filters
from pyrogram.enums import ChatType, ChatMemberStatus
from pyrogram.enums import ChatMemberStatus, ParseMode
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from VeGa.misc import SUDOERS
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, ReplyKeyboardMarkup
from pyrogram.types import (InlineKeyboardButton,CallbackQuery,InlineKeyboardMarkup, Message)
from VeGa.utils.database import (set_cmode,get_assistant)
from pyrogram.types import (InlineKeyboardButton, ChatPermissions, InlineKeyboardMarkup, Message, User)
from datetime import datetime
from pyrogram import enums
from config import OWNER_ID
from pyrogram.errors import MessageNotModified


from pyrogram.types import CallbackQuery

from pyrogram.types import CallbackQuery, InputMediaPhoto, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGa import app
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import *
from pyrogram.enums import ChatMembersFilter
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup                           
import asyncio
from VeGa import Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app
from VeGa import app
import pyrogram
from VeGa.misc import SUDOERS
from emoji import emojize
from config import *
from pyrogram import filters
from config import OWNER_ID
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.enums import ParseMode
from VeGa import app
from VeGa.utils.database import is_on_off
from config import LOGGER_ID


#Ù…ÙƒØ§ØªØ¨ ÙƒÙˆØ¯ Ù‚ÙˆÙ„ÙŠ

import asyncio
import aiohttp

import os
import time
import requests
from config import START_VIDS
from pyrogram import filters
import random
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import*
from pyrogram.enums import ChatType, ChatMemberStatus
from pyrogram.enums import ChatMembersFilter
from pyrogram import enums
from pyrogram import Client
from pyrogram import enums
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from random import  choice, randint
from pyrogram import Client, filters
from pyrogram.types import Message
from gtts import gTTS
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pydub import AudioSegment
from playsound import playsound
from pyrogram import Client, filters
from gtts import gTTS
import re
from pyrogram import Client, filters
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message
from cachetools import TTLCache
from VeGa.core.call import KIM
from VeGa.utils.database import get_assistant
from config import OWNER_ID
from VeGa.plugins.play.ADMANS import *


chat_locks = {}
id = {}  
user_messages = {}  
message_counts = {}  
amaerrof = []
welcome_messages = {}
welcome_locked = False
disabled_chats = []



# Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ø¹Ø§Ù…Ø©
class ChatLocks:
    def __init__(self, chat_id):
        self.chat_id = chat_id
        self.chat_locked = False
        self.mention_locked = False
        self.video_locked = False
        self.link_locked = False
        self.sticker_locked = False
        self.forward_locked = False
        self.photo_locked = False
        self.sound_locked = False
        self.voice_locked = False
        self.kalays_locked = False
        self.media_locked = False
        self.invite_locked = False
        self.pin_locked = False
        self.animation_locked = False
        # Ø§Ù„Ø³Ù…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        self.id_locked = False
        self.photo_cmd_locked = False
        self.reveal_locked = False
        self.beauty_locked = False
        self.group_info_locked = False
        self.welcome_locked = False
        # Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ù„ØºØ§Øª
        self.english_locked = False
        self.saap_locked = False
        self.persian_locked = False
        self.hebrew_locked = False
        self.arabic_locked = False
        self.hindi_locked = False
        self.numbers_locked = False
        self.oil_locked = False

        self.repeat_locked = False
        self.bots_locked = False
        self.notifications_locked = False
        self.edit_locked = False
        self.add_locked = False

def get_chat_locks(chat_id):
    if chat_id not in chat_locks:
        chat_locks[chat_id] = ChatLocks(chat_id)
    return chat_locks[chat_id]





def is_owner(_, __, message):
    if not message or not message.from_user:
        return False
    return message.from_user.id in [OWNER_ID, 7654641648]

async def is_admin(message):
    if not message or not message.from_user:
        return False
        
    user = message.from_user
    if user.id in [OWNER_ID, 7654641648]:
        return True
        
    try:
        member = await message.chat.get_member(user.id)
        return (member.status in [enums.ChatMemberStatus.OWNER] or
                is_owner(None, None, message) or
                is_mutaw(user.id) or
                is_malkeen(user.id) or
                is_admann(user.id))
    except:
        return False






def update_message_count(group_id, user_id):
    key = (group_id, user_id)
    if key not in message_counts:
        message_counts[key] = 0
    message_counts[key] += 1

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ù‡", "Ù‚ÙÙ„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"], ""), group=77721)
async def lock_chat(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER]:
         
        if message.chat.permissions.can_send_messages:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_send_messages=False))
            locks.chat_locked = True
            await message.reply_text(f"âœ… ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø¨ÙˆØ§Ø³Ø·Ø© {message.from_user.mention}")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ù…Ø§Ù„Ùƒ â« Ø¨Ø³")
         
         
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø¯Ø±Ø¯Ø´Ù‡", "ÙØªØ­ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"], ""), group=21755)
async def unlock_chat(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER]:
        if not message.chat.permissions.can_send_messages:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_send_messages=True))
            locks.chat_locked = False
            await message.reply_text(f"âœ… ØªÙ… ÙØªØ­ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø¨ÙˆØ§Ø³Ø·Ø© {message.from_user.mention}")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ù…Ø§Ù„Ùƒ â« Ø¨Ø³")
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ØªØ«Ø¨ÙŠØª
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª", ""), group=2541)
async def lock_pin(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if message.chat.permissions.can_pin_messages:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_pin_messages=False))
            locks.pin_locked = True
            await message.reply_text(f"â‡œÙ…Ù†  {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªØ«Ø¨ÙŠØª")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØªØ«Ø¨ÙŠØª Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")            
            
            
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØªØ«Ø¨ÙŠØª", ""), group=6621)
async def unlock_pin(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if not message.chat.permissions.can_pin_messages:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_pin_messages=True))
            locks.pin_locked = False
            await message.reply_text(f"â‡œÙ…Ù†{message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªØ«Ø¨ÙŠØª")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØªØ«Ø¨ÙŠØª Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")

    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø¯Ø¹ÙˆØ©
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø¯Ø¹ÙˆØ©", ""), group=2144)
async def lock_invite(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if message.chat.permissions.can_invite_users:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_invite_users=False))
            locks.invite_locked = True
            await message.reply_text(f"â‡œÙ…Ù† {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø¯Ø¹ÙˆØ©")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø¯Ø¹ÙˆØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")            
            
                     
            
            
            
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø¯Ø¹ÙˆØ©", ""), group=2441)
async def unlock_invite(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if not message.chat.permissions.can_invite_users:
            await app.set_chat_permissions(chat_id, ChatPermissions(can_invite_users=True))
            locks.invite_locked = False
            await message.reply_text(f"â‡œÙ…Ù† {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø¯Ø¹ÙˆØ©\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø¯Ø¹ÙˆØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ



# Ø¯Ø§Ù„Ø© Ù‚ÙÙ„ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§ (Ø¨Ø¯ÙˆÙ† ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©)
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§", "") & filters.group, group=281)
async def lock_media(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        
        if not locks.media_locked:
            locks.media_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ù…ÙŠØ¯ÙŠØ§\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ù†Ø¸Ø§Ù… Ø­Ø°Ù Ø§Ù„Ù…ÙŠØ¯ÙŠØ§ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("âš ï¸ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±")

# Ø¯Ø§Ù„Ø© ÙØªØ­ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§", "") & filters.group, group=282)
async def unlock_media(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        
        if locks.media_locked:
            locks.media_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ù…ÙŠØ¯ÙŠØ§\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ù†Ø¸Ø§Ù… Ø­Ø°Ù Ø§Ù„Ù…ÙŠØ¯ÙŠØ§ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("âš ï¸ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±")

# Ø¯Ø§Ù„Ø© Ø­Ø°Ù Ø§Ù„Ù…ÙŠØ¯ÙŠØ§ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
@app.on_message(
    (filters.photo | filters.video | filters.sticker | filters.animation | filters.document) &
    filters.group,
    group=283
)
async def auto_delete_media(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.media_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                
                await message.delete()
                warn_msg = await client.send_message(
                    chat_id,
                    f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙŠØ¯ÙŠØ§\nà¼„",
                    reply_to_message_id=message.id
                )
                await asyncio.sleep(5)
                await warn_msg.delete()
                
    except ChatAdminRequired:
        print(f"Ù„ÙŠØ³ Ù„Ø¯ÙŠ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø­Ø°Ù ÙÙŠ {chat_id}")
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…ÙŠØ¯ÙŠØ§: {e}")

# Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ø°Ù Ø§Ù„ÙŠØ¯ÙˆÙŠ
            
            
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

from pyrogram.types import ChatPermissions

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª", "") & filters.group, group=21)
async def lock_animations(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        get = await client.get_chat_member(chat_id, message.from_user.id)
        if (get.status in [ChatMemberStatus.OWNER] or 
            is_owner(None, None, message) or
            is_moteerr(message.from_user.id) or  
            is_mutaw(message.from_user.id) or 
            is_malkeen(message.from_user.id) or 
            is_admann(message.from_user.id)):
            
            if not locks.animation_locked:
                locks.animation_locked = True
                await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€â‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª\nà¼„")
            else:
                await message.reply_text("ğŸ”’ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚ÙÙ„ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª: {e}")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª", "") & filters.group, group=21)
async def unlock_animations(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        get = await client.get_chat_member(chat_id, message.from_user.id)
        if (get.status in [ChatMemberStatus.OWNER] or 
            is_owner(None, None, message) or
            is_moteerr(message.from_user.id) or  
            is_mutaw(message.from_user.id) or 
            is_malkeen(message.from_user.id) or 
            is_admann(message.from_user.id)):
            
            if locks.animation_locked:
                locks.animation_locked = False
                await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª\nà¼„")
            else:
                await message.reply_text("ğŸ”“ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ÙØªØ­ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª: {e}")

# Ø¯Ø§Ù„Ø© Ø­Ø°Ù Ø§Ù„Ù…ØªØ­Ø±ÙƒØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
@app.on_message(filters.animation & ~filters.create(is_owner) & filters.group, group=22)
async def delete_animations(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.animation_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ Ù…ØªØ­Ø±ÙƒØ§Øª Ù‡Ù†\nà¼„Ø§!")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©: {e}")
        
        
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯", "") & filters.group, group=21)
async def lock_voice(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if not locks.voice_locked:
            locks.voice_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯Ø§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯", "") & filters.group, group=2881)
async def unlock_voice(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if locks.voice_locked:
            locks.voice_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯Ø§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.voice & ~filters.create(is_owner) & filters.group, group=2000008)
async def delete_voice(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.voice_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention}  ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ Ø±ÙŠÙƒÙˆØ±Ø¯Ø§Øª Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØµÙˆØªÙŠØ©: {e}")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ØµÙˆØªÙŠØ§Øª
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØµÙˆØªÙŠØ§Øª", "") & filters.group, group=28661)
async def lock_audio(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)): 
        if not locks.sound_locked:
            locks.sound_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØµÙˆØªÙŠØ§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØµÙˆØªÙŠØ§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØµÙˆØªÙŠØ§Øª", "") & filters.group, group=28761)
async def unlock_audio(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)): 
        if locks.sound_locked:
            locks.sound_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØµÙˆØªÙŠØ§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØµÙˆØªÙŠØ§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.audio & ~filters.create(is_owner) & filters.group, group=28766)
async def delete_audio(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.sound_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ  {message.from_user.mention}  ã€\nâ‡œÙ…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØªÙŠØ§Øª Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„ØµÙˆØªÙŠØ©: {e}")
        
        
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ù…Ù†Ø´Ù†
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ù…Ù†Ø´Ù†", "") & filters.group, group=8721)
async def lock_mention(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):  
        if not locks.mention_locked:
            locks.mention_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ù…Ù†Ø´Ù† Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ù…Ù†Ø´Ù†", "") & filters.group, group=20071)
async def unlock_mention(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        if locks.mention_locked:
            locks.mention_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙŠÙˆØ²Ø±Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ù…Ù†Ø´Ù† Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.text & ~filters.create(is_owner) & filters.group, group=22110)
async def delete_mention(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.mention_locked and "@" in message.text:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø¹Ù…Ù„ Ù…Ù†Ø´Ù† Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ù†Ø´Ù†: {e}")
        
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ", "") & filters.group, group=21)
async def lock_video(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if not locks.video_locked:
            locks.video_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ", "") & filters.group, group=9821)
async def unlock_video(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if locks.video_locked:
            locks.video_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.video & ~filters.create(is_owner) & filters.group, group=200086)
async def delete_video(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.video_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {e}")
        
        
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡", ""), group=21)
async def lock_forward(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.forward_locked:
            locks.forward_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªÙˆØ¬ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡", ""), group=21)
async def unlock_forward(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.forward_locked:
            locks.forward_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªÙˆØ¬ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
         
@app.on_message(filters.forwarded & filters.group, group=2865)
async def delete_forward(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.forward_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…ÙˆØ¬Ù‡Ø©: {e}")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª", "") & filters.group, group=2641)
async def lock_sticker(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if not locks.sticker_locked:
            locks.sticker_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±!")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª", "") & filters.group, group=7521)
async def unlock_sticker(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(chat_id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if locks.sticker_locked:
            locks.sticker_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±!")

# Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø³ØªØ­Ø°Ù Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…Ù‚ÙÙ„Ø©
@app.on_message(filters.sticker & filters.group, group=2866)
async def delete_stickers(client, message):
    try:
        chat_id = message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.sticker_locked and message.from_user:
            member = await client.get_chat_member(chat_id, message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
                await message.delete()
                await message.reply_text(f"ã€Œ {message.from_user.mention}  ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª Ù‡Ù†Ø§!\nà¼„")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ù„ØµÙ‚: {e}")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ØµÙˆØ±
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØµÙˆØ±", ""), group=26531)
async def lock_photo(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if not locks.photo_locked:
            locks.photo_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØµÙˆØ±\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØµÙˆØ± Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØµÙˆØ±", ""), group=26541)
async def unlock_photo(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):  
        if locks.photo_locked:
            locks.photo_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØµÙˆØ±\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØµÙˆØ± Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.photo & ~filters.create(is_owner), group=2865)
async def delete_photo(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.photo_locked:
        member = await client.get_chat_member(chat_id, message.from_user.id)               
        if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
            await message.delete()
            await message.reply_text(f"ã€Œ  {message.from_user.mention}  ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ± Ù‡Ù†Ø§!\nà¼„")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", ""), group=27751)
async def lock_link(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if not locks.link_locked:
            locks.link_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø±ÙˆØ§Ø¨Ø·\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", ""), group=2108)
async def unlock_link(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):  
        if locks.link_locked:
            locks.link_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø±ÙˆØ§Ø¨Ø·\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")

@app.on_message(filters.text & ~filters.create(is_owner), group=2244)
async def delete_link(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.link_locked and ("http://" in message.text or "https://" in message.text or "t.me" in message.text):
        # Get the member information first
        member = await client.get_chat_member(chat_id, message.from_user.id)       
        if not (member.status in [ChatMemberStatus.OWNER] or
               is_owner(None, None, message) or
               is_moteerr(message.from_user.id) or 
               is_mutaw(message.from_user.id) or
               is_malkeen(message.from_user.id) or
               is_admann(message.from_user.id)):
            await message.delete()
            await message.reply_text(f"ã€Œ  {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ Ø±ÙˆØ§Ø¨Ø· Ù‡Ù†Ø§!\nà¼„")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ÙƒÙ„Ø§ÙŠØ´
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ÙƒÙ„Ø§ÙŠØ´", ""), group=23211)
async def lock_long_text(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if not locks.kalays_locked:
            locks.kalays_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙƒÙ„Ø§ÙŠØ´\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ÙƒÙ„Ø§ÙŠØ´ Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ÙƒÙ„Ø§ÙŠØ´", ""), group=232151)
async def unlock_long_text(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if locks.kalays_locked:
            locks.kalays_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙƒÙ„Ø§ÙŠØ´\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ÙƒÙ„Ø§ÙŠØ´ Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.text & ~filters.create(is_owner), group=29876)
async def delete_long_text(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.kalays_locked and len(message.text) > 200:
        if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, message) or
                   is_moteerr(message.from_user.id) or 
                   is_mutaw(message.from_user.id) or
                   is_malkeen(message.from_user.id) or
                   is_admann(message.from_user.id)):
            await message.delete()
            await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„Ø§ÙŠØ´ Ø·ÙˆÙŠÙ„Ø© Ù‡Ù†Ø§!\nà¼„")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ÙƒÙ„
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ÙƒÙ„", ""), group=75521)
async def lock_all(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        
        if locks.chat_locked:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
            return
            
        await app.set_chat_permissions(chat_id, ChatPermissions(
            can_send_messages=False,
            can_send_media_messages=False,
            can_send_other_messages=False,
            can_add_web_page_previews=False,
            can_invite_users=False,
            can_pin_messages=False,
            can_change_info=False,
            can_send_polls=False
        ))
        
        if chat_id not in amaerrof:
            amaerrof.append(chat_id)
        
        # ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø¥Ù„Ù‰ True
        locks.chat_locked = True
        locks.mention_locked = True
        locks.video_locked = True
        locks.link_locked = True
        locks.sticker_locked = True
        locks.forward_locked = True
        locks.photo_locked = True
        locks.sound_locked = True
        locks.voice_locked = True
        locks.kalays_locked = True
        locks.media_locked = True
        locks.invite_locked = True
        locks.pin_locked = True
        locks.animation_locked = True
        locks.id_locked = True
        locks.photo_cmd_locked = True
        locks.reveal_locked = True
        locks.beauty_locked = True
        locks.group_info_locked = True
        locks.welcome_locked = True
        locks.english_locked = True
        locks.saap_locked = True
        locks.persian_locked = True
        locks.hebrew_locked = True
        locks.arabic_locked = True
        locks.hindi_locked = True
        locks.numbers_locked = True
        locks.oil_locked = True
        
        locks.repeat_locked = True
        locks.bots_locked = True
        locks.notifications_locked = True
        locks.edit_locked = True
        locks.add_locked = True
        
        await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙƒÙ„\nà¼„")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ÙƒÙ„", ""), group=2971)
async def unlock_all(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        
        if not locks.chat_locked:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
            return
            
        # ÙØªØ­ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
        await app.set_chat_permissions(chat_id, ChatPermissions(
            can_send_messages=True,
            can_send_media_messages=True,
            can_send_other_messages=True,
            can_add_web_page_previews=True,
            can_invite_users=True,
            can_pin_messages=True,
            can_change_info=True,
            can_send_polls=True
        ))
        
        # ØªÙØ¹ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙˆØ§Ù…Ø±
        if chat_id in amaerrof:
            amaerrof.remove(chat_id)
        
        # ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø¥Ù„Ù‰ False
        locks.chat_locked = False
        locks.mention_locked = False
        locks.video_locked = False
        locks.link_locked = False
        locks.sticker_locked = False
        locks.forward_locked = False
        locks.photo_locked = False
        locks.sound_locked = False
        locks.voice_locked = False
        locks.kalays_locked = False
        locks.media_locked = False
        locks.invite_locked = False
        locks.pin_locked = False
        locks.animation_locked = False
        locks.id_locked = False
        locks.photo_cmd_locked = False
        locks.reveal_locked = False
        locks.beauty_locked = False
        locks.group_info_locked = False
        locks.welcome_locked = False
        locks.english_locked = False
        locks.saap_locked = False
        locks.persian_locked = False
        locks.hebrew_locked = False
        locks.arabic_locked = False
        locks.hindi_locked = False
        locks.numbers_locked = False
        locks.oil_locked = False
        
        locks.repeat_locked = False
        locks.bots_locked = False
        locks.notifications_locked = False
        locks.edit_locked = False
        locks.add_locked = False
        
        await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙƒÙ„\nà¼„")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ù„ØºØ§Øª
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡", "") & filters.group, group=2772)
async def lock_english(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.english_locked:
            locks.english_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡", "") & filters.group, group=181819)
async def unlock_english(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.english_locked:
            locks.english_locked = False
            await message.reply_text(f"â‡œÙ…Ù† ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ÙØ§Ø±Ø³ÙŠÙ‡", "") & filters.group, group=6544)
async def lock_persian(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if not locks.persian_locked:
            locks.persian_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙØ§Ø±Ø³ÙŠØ©\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„ÙØ§Ø±Ø³ÙŠØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ÙØ§Ø±Ø³ÙŠÙ‡", "") & filters.group, group=652)
async def unlock_persian(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        if locks.persian_locked:
            locks.persian_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙØ§Ø±Ø³ÙŠØ©")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„ÙØ§Ø±Ø³ÙŠØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡", "") & filters.group, group=297)
async def lock_hebrew(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        if not locks.hebrew_locked:
            locks.hebrew_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø¨Ø±ÙŠØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡", "") & filters.group, group=2977)
async def unlock_hebrew(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):  
        if locks.hebrew_locked:
            locks.hebrew_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø¨Ø±ÙŠØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠÙ‡", "") & filters.group, group=4444)
async def lock_arabic(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if not locks.arabic_locked:
            locks.arabic_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø¹Ø±Ø¨ÙŠÙ‡", "") & filters.group, group=232)
async def unlock_arabic(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if locks.arabic_locked:
            locks.arabic_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
         
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ù‡Ù†Ø¯ÙŠÙ‡", "") & filters.group, group=243)
async def lock_hindi(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):  
        if not locks.hindi_locked:
            locks.hindi_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ù‡Ù†Ø¯ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ù‡Ù†Ø¯ÙŠÙ‡", "") & filters.group, group=2211)
async def unlock_hindi(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if locks.hindi_locked:
            locks.hindi_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ù‡Ù†Ø¯ÙŠÙ‡\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ù„ØºØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø§Ø±Ù‚Ø§Ù…", "") & filters.group, group=2135)
async def lock_numbers(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if not locks.numbers_locked:
            locks.numbers_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§Ø±Ù‚Ø§Ù…\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø§Ø±Ù‚Ø§Ù…", "") & filters.group, group=2765)
async def unlock_numbers(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if locks.numbers_locked:
            locks.numbers_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§Ø±Ù‚Ø§Ù…\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†", "") & filters.group, group=2876)
async def lock_oil(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)): 
        if not locks.oil_locked:
            locks.oil_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ† Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†", "") & filters.group, group=29766)
async def unlock_oil(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   
        if locks.oil_locked:
            locks.oil_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†\nà¼„")
        else:
            await message.reply_text("âš ï¸ Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ† Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.text & ~filters.create(is_owner), group=27544)
async def delete_other_content(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if not await is_admin(message):
        text = message.text

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        if locks.arabic_locked and any('\u0600' <= c <= '\u06FF' for c in text):
            await message.delete()
            await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\nà¼„")
        
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù„ØºØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ©
        elif locks.hindi_locked and any('\u0900' <= c <= '\u097F' for c in text):
            await message.delete()
            await message.reply_text(f"ã€Œ {message.from_user.mention} ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ©\nà¼„")
        
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
        elif locks.numbers_locked and any(c.isdigit() for c in text):
            await message.delete()
            await message.reply_text(f"ã€Œ  {message.from_user.mention} ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù…\nà¼„")
        
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù†Ù‚Ø·Ø© (ÙƒÙ„Ù…Ø© ØªÙ„ÙŠØ«ÙˆÙ†)
        elif locks.oil_locked and "." in text:
            await message.delete()
            await message.reply_text(f"ã€Œ  {message.from_user.mention} ã€\nÙ…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ† \nà¼„")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø£ÙˆØ§Ù…Ø±
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø§ÙˆØ§Ù…Ø±", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§ÙˆØ§Ù…Ø±"], "") & filters.group, group=2443)
async def lock_commands(client, message):
    chat_id = message.chat.id
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   

    
        if chat_id in amaerrof:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù…Ø¹Ø·Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            amaerrof.append(chat_id)
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§ÙˆØ§Ù…Ø±\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø§ÙˆØ§Ù…Ø±", "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§ÙˆØ§Ù…Ø±"], "") & filters.group, group=2755)
async def unlock_commands(client, message):
    chat_id = message.chat.id
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):   


    
        if chat_id not in amaerrof:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù…ÙØ¹Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            amaerrof.remove(chat_id)
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§ÙˆØ§Ù…Ø±\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø£ÙŠØ¯ÙŠ
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ"], "") & filters.group, group=2666)
async def lock_id(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.id_locked:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£ÙŠØ¯ÙŠ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.id_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§ÙŠØ¯ÙŠ\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø§ÙŠØ¯ÙŠ", "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§ÙŠØ¯ÙŠ"], "") & filters.group, group=26655)
async def unlock_id(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.id_locked:
            await message.reply_text("âš ï¸ Ø§Ù„Ø£ÙŠØ¯ÙŠ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.id_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§ÙŠØ¯ÙŠ\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ ØµÙˆØ±ØªÙŠ
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ ØµÙˆØ±ØªÙŠ", "ØªØ¹Ø·ÙŠÙ„ ØµÙˆØ±ØªÙŠ"], "") & filters.group, group=2976)
async def lock_photo_cmd(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.photo_cmd_locked:
            await message.reply_text("âš ï¸ ØµÙˆØ±ØªÙŠ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.photo_cmd_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª ØµÙˆØ±ØªÙŠ\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command(["ÙØªØ­ ØµÙˆØ±ØªÙŠ", "ØªÙØ¹ÙŠÙ„ ØµÙˆØ±ØªÙŠ"], "") & filters.group, group=2211)
async def unlock_photo_cmd(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.photo_cmd_locked:
            await message.reply_text("âš ï¸ ØµÙˆØ±ØªÙŠ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.photo_cmd_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª ØµÙˆØ±ØªÙŠ\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ÙƒØ´Ù
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„ÙƒØ´Ù", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ÙƒØ´Ù"], "") & filters.group, group=22345)
async def lock_reveal(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.reveal_locked:
            await message.reply_text("âš ï¸ Ø§Ù„ÙƒØ´Ù Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.reveal_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ÙƒØ´Ù\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„ÙƒØ´Ù", "ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙƒØ´Ù"], "") & filters.group, group=2532)
async def unlock_reveal(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.reveal_locked:
            await message.reply_text("âš ï¸ Ø§Ù„ÙƒØ´Ù Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.reveal_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ÙƒØ´Ù\nà¼„")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø¬Ù…Ø§Ù„ÙŠ
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø¬Ù…Ø§Ù„ÙŠ", "ØªØ¹Ø·ÙŠÙ„ Ø¬Ù…Ø§Ù„ÙŠ"], "") & filters.group, group=2433)
async def lock_beauty(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.beauty_locked:
            await message.reply_text("âš ï¸ Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.beauty_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø¬Ù…Ø§Ù„ÙŠ\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø¬Ù…Ø§Ù„ÙŠ", "ØªÙØ¹ÙŠÙ„ Ø¬Ù…Ø§Ù„ÙŠ"], "") & filters.group, group=2854)
async def unlock_beauty(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.beauty_locked:
            await message.reply_text("âš ï¸ Ø¬Ù…Ø§Ù„ÙŠ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.beauty_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø¬Ù…Ø§Ù„ÙŠ")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø±ÙˆØ¨
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨"], "") & filters.group, group=2986)
async def lock_group_info(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.group_info_locked:
            await message.reply_text("âš ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø±ÙˆØ¨ Ù…Ø¹Ø·Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.group_info_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø¬Ø±ÙˆØ¨\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø¬Ø±ÙˆØ¨", "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨"], "") & filters.group, group=2866)
async def unlock_group_info(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.group_info_locked:
            await message.reply_text("âš ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø±ÙˆØ¨ Ù…ÙØ¹Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.group_info_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø¬Ø±ÙˆØ¨\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„ØªØ±Ø­ÙŠØ¨
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨"], "") & filters.group, group=2975)
async def lock_welcome(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if locks.welcome_locked:
            await message.reply_text("âš ï¸ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.welcome_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªØ±Ø­ÙŠØ¨\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
         
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„ØªØ±Ø­ÙŠØ¨", "ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ±Ø­ÙŠØ¨"], "") & filters.group, group=2321)
async def unlock_welcome(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):


    
        if not locks.welcome_locked:
            await message.reply_text("âš ï¸ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.welcome_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªØ±Ø­ÙŠØ¨\nà¼„")
    else:
         await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
         
         
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£ÙŠØ¯ÙŠ ÙˆØ§Ù„Ù…Ø¹Ø¬Ø¨ÙŠÙ†
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.command(["Ø§ÙŠØ¯ÙŠ","Ø§Ù„Ø§ÙŠØ¯ÙŠ","Ø§","id","/id","/ID"], ""), group=99)
async def muid(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.id_locked:
        return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹Ø·Ù„")
    
    try:
        user = await client.get_chat(message.from_user.id)
        user_id = message.from_user.id if message and message.from_user else None
        if user_id is None:
            return
        
        username = user.username
        display_username = username or "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        first_name = user.first_name or "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        bioo = user.bio or "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        photo = user.photo.big_file_id if user.photo else None
        
        if user.id not in id:
            id[user.id] = []
        idd = len(id[user.id])
        
        buttons = []
        row_buttons = []
        
        if username:
            buttons.append(
                [InlineKeyboardButton(first_name, url=f"https://t.me/{username}")]
            )
        
        row_buttons.append(
            InlineKeyboardButton(f"{idd} â¤ï¸", callback_data=f"heart{user_id}")
        )
        row_buttons.append(
            InlineKeyboardButton("ğŸ‘¥ Ø§Ù„Ù…Ø¹Ø¬Ø¨ÙŠÙ†", callback_data=f"fans_{user_id}_{message.from_user.id}")
        )
        buttons.append(row_buttons)
        
        caption = (
            f"â€¢<b><u>Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ :</u>\n\nâ€¢ Ø§Ù„Ø§Ø³Ù… : {message.from_user.mention}\n"
            f"â€¢ Ø§Ù„Ù…Ø¹Ø±Ù : @{display_username}\n"
            f"â€¢ Ø§Ù„Ø§ÙŠØ¯ÙŠ : <code>{user_id}</code>\n"
            f"â€¢ Ø§Ù„Ø¨Ø§ÙŠÙˆ : {bioo}\n"
            f"â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© : {message.chat.title}\n"
            f"â€¢ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <code>{message.chat.id}</code></b>"
        )
        
        if photo:
            photo = await client.download_media(photo)
            await message.reply_photo(
                photo=photo,
                caption=caption,
                reply_markup=InlineKeyboardMarkup(buttons),
                has_spoiler=True
            )
        else:
            await message.reply_text(
                caption,
                reply_markup=InlineKeyboardMarkup(buttons))
    except Exception as e:
        print(f"An error occurred: {e}")

@app.on_callback_query(filters.regex("^heart"), group=54787866)
async def heart(client, query: CallbackQuery):  
    callback_data = query.data.strip()  
    callback_request = callback_data.replace("heart", "")  
    username = int(callback_request)
    
    try:
        usr = await client.get_chat(username)
        heart_giver = query.from_user.id
        
        if usr.id not in id:
            id[usr.id] = []
            
        if heart_giver not in id[usr.id]:
            id[usr.id].append(heart_giver)
            fan_count = len(id[usr.id])
        else:
            await query.answer("Ù„Ù‚Ø¯ Ø£Ø¹Ø¬Ø¨Øª Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„!", show_alert=True)
            return
        
        idd = len(id[usr.id])
        
        buttons = []
        row_buttons = []
        
        if usr.username:
            buttons.append(
                [InlineKeyboardButton(usr.first_name, url=f"https://t.me/{usr.username}")]
            )
        
        row_buttons.append(
            InlineKeyboardButton(f"{idd} â¤ï¸", callback_data=f"heart{usr.id}")
        )
        row_buttons.append(
            InlineKeyboardButton("ğŸ‘¥ Ø§Ù„Ù…Ø¹Ø¬Ø¨ÙŠÙ†", callback_data=f"fans_{usr.id}_{query.from_user.id}")
        )
        buttons.append(row_buttons)
        
        await query.edit_message_reply_markup(
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        await query.answer(f"â¤ï¸ Ø£Ø¹Ø¬Ø¨Øª Ø¨Ù€ {usr.first_name}", show_alert=False)
        
    except Exception as e:
        print(f"An error occurred: {e}")
        await query.answer("Ø­Ø¯Ø« Ø®Ø·Ø£!", show_alert=True)

@app.on_callback_query(filters.regex("^fans_"), group=54787867)
async def show_fans(client, query: CallbackQuery):
    callback_data = query.data.strip()
    parts = callback_data.split('_')
    user_id = int(parts[1])
    requester_id = int(parts[2])
    
    if query.from_user.id != requester_id:
        await query.answer("âŒ ÙÙ‚Ø· ØµØ§Ø­Ø¨ Ø§Ù„Ø£Ù…Ø± ÙŠÙ…ÙƒÙ†Ù‡ Ø±Ø¤ÙŠØ© Ø§Ù„Ù…Ø¹Ø¬Ø¨ÙŠÙ†", show_alert=True)
        return
    
    try:
        user = await client.get_chat(user_id)
        if user_id not in id or not id[user_id]:
            fans_list = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø¬Ø¨ÙŠÙ† Ø¨Ø¹Ø¯"
        else:
            fans_list = f"ğŸ‘¥ Ù…Ø¹Ø¬Ø¨ÙŠ {user.first_name}:\n\n"
            for fan_id in id[user_id]:
                try:
                    fan_user = await client.get_chat(fan_id)
                    fans_list += f"â€¢ {fan_user.first_name}"
                    if fan_user.username:
                        fans_list += f" (@{fan_user.username})"
                    fans_list += "\n"
                except:
                    fans_list += f"â€¢ Ù…Ø³ØªØ®Ø¯Ù… (ID: {fan_id})\n"
        
        await query.answer(fans_list, show_alert=True)
    except Exception as e:
        print(f"An error occurred: {e}")
        await query.answer("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø¬Ø¨ÙŠÙ†!", show_alert=True)

@app.on_message(filters.command(["ÙÙ†Ø²Ø§ØªÙŠ", "Ø§Ù„Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†"], ""), group=5847878)
async def get_mt_fans(client: Client, message: Message):
    user_id = message.from_user.id if message and message.from_user else None
    fan_count = len(id.get(user_id, []))
    fann_count = "79911"
    
    if user_id == 7654641648:
        return await message.reply_text(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fann_count} â¤ï¸")
    
    if fan_count == 0:
        await message.reply_text("Ù„ÙŠØ³ Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†")
    else:
        await message.reply_text(f"<blockquote>Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fan_count} â¤ï¸</blockquote>")

@app.on_message(filters.command(["ÙÙ†Ø²Ø§ØªÙ‡", "Ø§Ù„Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†"], ""), group=5847878)
async def get_mt_fans(client: Client, message: Message):
    user_id = message.reply_to_message.from_user.id
    fan_count = len(id.get(user_id, []))
    fann_count = "79911"
    
    if user_id == 7654641648:
        return await message.reply_text(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fann_count} â¤ï¸")
    
    if fan_count == 0:
        await message.reply_text("Ù„ÙŠØ³ Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø¬Ø§Ø¨ÙŠÙ†")
    else:
        await message.reply_text(f"<blockquote>Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„Ø¯ÙŠÙƒ: {fan_count} â¤ï¸</blockquote>")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± ØµÙˆØ±ØªÙŠ ÙˆØ¬Ù…Ø§Ù„ÙŠ
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

RAEAK = ["ÙØ§Ø¬Ø±Ù‡","Ø­Ù„ÙˆÙ‡","ÙØ®Ø§Ù…Ù‡","Ø¬Ù…ÙŠÙ„Ù‡","Ø®ÙˆØ´","Ø¬Ù…ÙŠÙ„Ù‡","ÙŠØ¹Ø¹Ø¹Ø¹Ø¹","ÙˆØ­Ø´Ù‡","Ù…Ø´ Ø­Ù„ÙˆÙ‡","Ø­Ù„ÙˆÙ‡ ÙŠØ§Ø¹Ù…","Ø®Ù„ÙŠÙƒ Ø¨ÙŠÙ‡Ø§","Ø­Ø¨ØªÙ‡Ø§","ØºÙŠØ±Ù‡Ø§ ÙŠØ¹Ù…"]

@app.on_message(filters.command(["ØµÙˆØ±ØªÙŠ"], ""), group=104)
async def mgssggg(client: Client, message: Message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.photo_cmd_locked:
        return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹Ø·Ù„")
      
    usr = await client.get_users(message.from_user.id)
    name = usr.first_name
    user_id = message.from_user.id if message and message.from_user else None
        
    name = usr.first_name
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)

        await message.reply_photo(photo=photo, caption=f"""<b> Ëšâ€§VEGAË³+\nâ•®â—‰ Ø§Ù†Ø§ ÙƒØ§ Ø¨ÙˆØª Ù‡Ù‚ÙˆÙ„\nâ€£ Ø±Ø£ÙŠÙŠ ÙŠØ§ : {message.from_user.mention}\nâ•¯â—‰ ÙÙŠ ØµÙˆØ±ØªÙƒ:- ( {choice(RAEAK)} )</b>""", 
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        ),
    )
    else:
        await message.reply_text("Ù‡ÙŠÙŠÙ‡ Ù…Ø¹Ù†Ø¯Ùƒ ØµÙˆØ±Ù‡ ÙŠØ§Ø±ÙˆØ¹!")        







import random
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram import filters

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¢Ø±Ø§Ø¡
RAEAK = ["ÙØ§Ø¬Ø±Ù‡", "Ø­Ù„ÙˆÙ‡", "ÙØ®Ø§Ù…Ù‡", "Ø¬Ù…ÙŠÙ„Ù‡", "Ø®ÙˆØ´", "Ø¬Ù…ÙŠÙ„Ù‡", "ÙŠØ¹Ø¹Ø¹Ø¹Ø¹",
        "ÙˆØ­Ø´Ù‡", "Ù…Ø´ Ø­Ù„ÙˆÙ‡", "Ø­Ù„ÙˆÙ‡ ÙŠØ§Ø¹Ù…", "Ø®Ù„ÙŠÙƒ Ø¨ÙŠÙ‡Ø§", "Ø­Ø¨ØªÙ‡Ø§", "ØºÙŠØ±Ù‡Ø§ ÙŠØ¹Ù…"]
RANDOM_PHOTOS = [
    "https://files.catbox.moe/cwyn9i.jpg",
    "https://files.catbox.moe/qp5a9h.jpg",
    "https://files.catbox.moe/ueaicb.jpg",
    "https://files.catbox.moe/ge20g4.jpg",
    "https://files.catbox.moe/oiamot.jpg",
    "https://files.catbox.moe/lyd0uq.jpg",
    "https://files.catbox.moe/puxeyb.jpg",
    "https://files.catbox.moe/67mq32.jpg",
    "https://files.catbox.moe/65hsqt.jpg",
    "https://files.catbox.moe/qwmxdo.jpg",
    "https://files.catbox.moe/deenoy.jpg",
    "https://files.catbox.moe/2fsdsu.jpg",
    "https://files.catbox.moe/h0lvj2.jpg",
]

@app.on_message(filters.command(["ØµÙˆØ±Ù†ÙŠ"], ""), group=104)
async def random_photond(client: Client, message: Message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.photo_cmd_locked:
        return await message.reply_text("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹Ø·Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹")
    
    try:
        user = await client.get_users(message.from_user.id)
        username = f"@{user.username}" if user.username else user.first_name
        random_photo = random.choice(RANDOM_PHOTOS)
        random_opinion = random.choice(RAEAK)
        await message.reply_photo(
            photo=random_photo,
            caption=f"""<b>
            ğŸŒŸ ØªÙ… Ù„Ù‚Ø·Ø§Øª ØµÙˆØ±Ù‡ Ù„Ù„Ø°ÙƒØ±Ù‡ Ù„Ùƒ ğŸŒŸ
            
            ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user.mention}
            ğŸ’¬ Ø±Ø£ÙŠÙŠ ÙÙŠ ØµÙˆØ±ØªÙƒ: {random_opinion}
            {random.choice(["ğŸ”¥", "âœ¨", "ğŸŒ¸", "ğŸ’«"])} Ø²ÙƒØ±ÙŠØ§ØªÙƒ Ø§Ù„Ø­Ù„ÙˆÙ‡ Ù…Ø¹Ø§Ù†Ø§!</b>
            """,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    text=f"{user.first_name}",
                    url=f"https://t.me/{user.username}" if user.username else f"tg://user?id={user.id}"
                )]
            ])
        )
        
    except Exception as e:
        print(f"Error: {e}")
        await message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ!")


@app.on_message(filters.command(["Ø¬Ù…Ø§Ù„ÙŠ"], ""), group=104)
async def idjjdd(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.beauty_locked:
        return await message.reply_text("ğŸ›‘ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹Ø·Ù„ Ø­Ø§Ù„ÙŠÙ‹Ø§!")
    
    usr = await client.get_chat(message.from_user.id)
    name = usr.first_name
    beauty_levels = ["âœ¨10%", "ğŸŒ¸15%", "ğŸŒ™20%", "ğŸ’«25%", "ğŸŒ 30%", 
                    "ğŸŒ¹35%", "ğŸ¦‹40%", "ğŸ”®45%", "ğŸ’50%", "ğŸƒ55%",
                    "ğŸŒŒ60%", "ğŸª·66%", "ğŸŒº70%", "ğŸ•Šï¸77%", "ğŸŒ…80%",
                    "ğŸ€85%", "ğŸŒŠ90%", "ğŸ€99%", "ğŸ’¯100%", "â™¾ï¸1000%"]
    
    chosen_level = random.choice(beauty_levels)
    
    if usr.photo:
        photo = await app.download_media(usr.photo.big_file_id)
        await message.reply_photo(
            photo,
            caption=f"""<b>â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ\nâ€¢ Ù‡Ù„ Ø®Ù„Ù‚ Ø§Ù„Ø¬Ù…Ø§Ù„ Ù„ØªØ®ØªØµØ±Ù‡ Ø¹ÙŠÙ†Ø§Ùƒ Ø§Ù…Ø§\nâ€¢ Ø¹ÙŠÙ†Ø§Ùƒ Ø®Ù„Ù‚Øª Ù„ØªÙ‚Ù†Ø¹Ù†ÙŠ Ø§Ù† Ù„Ø§ Ø¬Ù…Ø§Ù„ Ø¨Ø¹Ø¯Ù‡Ø§ â¤ï¸</b>\n
            âœ¦ Ø¬Ù…Ø§Ù„ Ø¹ÙŠÙ†Ø§Ùƒ: **{chosen_level}** â¤ï¸ğŸ”¥
            <b>\nâ”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ""",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    f"ğŸŒ· {name} ğŸŒ·", 
                    url=f"https://t.me/{message.from_user.username}")
                ]
            ])
        )
    else:
        await message.reply_text("""
        ğŸŒ¸ Ù‡ÙŠÙŠÙ‡!
        âœ§ï½¥ï¾Ÿ: Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„!
        â¤ï¸â€ğŸ”¥ Ø£Ø¶Ù ØµÙˆØ±Ø© Ù„ØªØ±Ù‰ Ø¬Ù…Ø§Ù„Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ!
        """)

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„ÙƒØ´Ù
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

async def get_user_status(user_id: int, message):
    chat_id = message.chat.id
    member = await app.get_chat_member(chat_id, user_id)
    rank = "Ø¹Ø¶Ùˆ Ø­Ù‚ÙŠØ±"
    
    if user_id == 8122544723:
        rank = "Ù…Ø·ÙˆØ± ÙÙŠØ¬Ø§"
    elif user_id == 7654641648:
        rank = "ÙÙŠØ¬Ø§"
    elif user_id == OWNER_ID:
        rank = "Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØª"
    elif member.status == ChatMemberStatus.OWNER:
        rank = "Ù…Ø§Ù„Ùƒ Ø§Ù„Ø§Ø³Ø§Ø³ÙŠ"
    elif member.status == ChatMemberStatus.ADMINISTRATOR:
        rank = "Ù…Ø´Ø±Ù"
    
    return rank

@app.on_message(filters.command(["ÙƒØ´Ù", "Ø§Ù„ÙƒØ´Ù"], "") & filters.group, group=1024)
async def reveal_user_info(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    if locks.reveal_locked:
        return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹Ø·Ù„")
    
    if not message.reply_to_message:
        return await message.reply_text("âŒ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±")

    try:
        target_user = message.reply_to_message.from_user 
        user_id = target_user.id
        chat = message.chat
        username = f"@{target_user.username}" if target_user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±"
        profile_link = f"https://t.me/{target_user.username}" if target_user.username else f"tg://user?id={user_id}"
        
        user_info = await client.get_chat(user_id)
        bio = user_info.bio if user_info.bio else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ"
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
        dc_id = getattr(target_user, "dc_id", "ØºÙŠØ± Ù…ØªÙˆÙØ±")
        
        lang = getattr(target_user, "language_code", "ØºÙŠØ± Ù…ØªÙˆÙØ±")
        
        rank = await get_user_status(user_id, message)
        fan_count = len(id.get(user_id, [])) if user_id in id else 0
        messages = user_messages.get(str(chat.id), {}).get(str(user_id), []) if str(chat.id) in user_messages and str(user_id) in user_messages[str(chat.id)] else []

        random_phrases = ["ØªØ¹Ø¨Ø§Ù†", "Ø¹Ù†Ø¯Ù‡ Ø¨Ø±Ø¯", "Ø³Ø®Ù†", "Ù‡Ø¨ÙˆØ·", "Ø¨ÙŠØªÙƒÙˆÙ‡Ù†", "Ø¨ÙŠØªØ¹Ù„Ù‚", "Ø¨ÙŠØªÙ…Ø­Ù†", "Ø¨ÙŠØ³ØªÙ‡Ø¨Ù„", "Ø¹ÙŠØ§Ù†", "ÙÙŠ Ø§Ù„Ù†Ø§Ø²Ù„"]
        random_phrase = choice(random_phrases)
        button = InlineKeyboardMarkup([[InlineKeyboardButton(target_user.first_name, url=profile_link)]])

        caption = (
            f"<b><u>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡ÙŠ </u>:\n\n<b>â€¢  Ø§Ù„Ø§Ø³Ù… : {target_user.mention()}\n"
            f"â€¢ Ø§Ù„ÙŠÙˆØ²Ø± : {username}\n"
            f"â€¢ Ø§Ù„Ø¢ÙŠØ¯ÙŠ : <code>{user_id}</code>\n"
            f"â€¢ Ø§Ù„Ø­Ø§Ù„Ø© : {random_phrase}\n"
            f"â€¢ Ø§Ù„Ø¥Ø¹Ø¬Ø§Ø¨Ø§Øª : {fan_count}\n"
            f"â€¢ Ø§Ù„Ø±ØªØ¨Ø© : {rank}\n"
            f"â€¢ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ : {len(messages)}\n"
            f"â€¢ Ø§Ù„Ø¨Ø§ÙŠÙˆ : {bio}\n"
            f" â€¢ Ø­Ø³Ø§Ø¨ Ù…ÙˆØ«Ù‚ : {'Ù†Ø¹Ù… ğŸ’' if target_user.is_premium else 'Ù„Ø§ '}\n"
            f"â€¢ Ø¨ÙˆØª : {'Ù†Ø¹Ù… ' if target_user.is_bot else 'Ù„Ø§ '}\n"
            f"â€¢ Ø­Ø³Ø§Ø¨ Ø§Ø­ØªÙŠØ§Ù„ÙŠ : {'Ù†Ø¹Ù… ' if getattr(target_user, 'is_scam', False) else 'Ù„Ø§ '}\n"
            f"â€¢ ØµÙˆØ±Ø© Ø¨Ø±ÙˆÙØ§ÙŠÙ„ : {'Ù†Ø¹Ù… ' if target_user.photo else 'Ù„Ø§ '}\n</b>"
            f"â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© : {chat.title}\n"
            f"â€¢ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© : <code>{chat.id}</code></b>\n"
            f"â€¢ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© : @{chat.username if chat.username else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}"
            
        )

        if user_info.photo:
            photo = user_info.photo.big_file_id
            photo_path = await app.download_media(photo)
            await message.reply_photo(
                photo=photo_path,
                caption=caption,
                reply_markup=button,
                has_spoiler=True
            )
        else:
            await message.reply_text(
                caption,
                reply_markup=button
            )

    except Exception as e:
        print(f"Error: {e}")
        await message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ø±Ø³Ø§ÙŠÙ„ÙŠ ÙˆØ±Ø³Ø§ÙŠÙ„Ù‡
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

@app.on_message(filters.regex("^Ø±Ø³Ø§ÙŠÙ„ÙŠ$") & filters.group, group=62839499)
async def show_my_messages(client, message):
    chat_id = str(message.chat.id)
    user_id = str(message.from_user.id)
    messages = user_messages.get(chat_id, {}).get(user_id, [])
    await message.reply(f"<blockquote>Â» Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ùƒ : {len(messages)}</blockquote>")

@app.on_message(filters.regex("^Ø±Ø³Ø§ÙŠÙ„Ù‡$") & filters.group, group=6283949968)
async def show_his_messages(client, message):
    if not message.reply_to_message:
        return await message.reply_text("âŒ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±")
    
    chat_id = str(message.chat.id)
    user_id = str(message.reply_to_message.from_user.id)
    messages = user_messages.get(chat_id, {}).get(user_id, [])
    await message.reply(f"Â» <blockquote>Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ù‡ : {len(messages)}</blockquote>")

@app.on_message(filters.text & filters.group, group=15363729)
async def store_message(client, message):
    if not message or not message.from_user:
        return
        
    chat_id = str(message.chat.id)
    user_id = str(message.from_user.id)
    if chat_id not in user_messages:
        user_messages[chat_id] = {}
    if user_id not in user_messages[chat_id]:
        user_messages[chat_id][user_id] = []
    user_messages[chat_id][user_id].append(message.text)

# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ø­Ù…Ø§ÙŠØ©
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

async def send_status_message(client, chat_id, reply_to_message_id=None, keyboard=None):
    locks = get_chat_locks(chat_id)
    status_message = "- <b>Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ù…Ø§ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:</b>\n\n"
    
    try:
        chat = await client.get_chat(chat_id)
        permissions = chat.permissions
    except:
        permissions = None
    
    # Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    status_message += "<b>Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:</b>\n"
    status_message += f"Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if permissions and not permissions.can_send_messages else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ù…ÙŠØ¯ÙŠØ§: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if permissions and not permissions.can_send_media_messages else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„ØªØ«Ø¨ÙŠØª: {'- Ù…Ù‚ÙÙ„' if permissions and not permissions.can_pin_messages else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„Ø¯Ø¹ÙˆØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if permissions and not permissions.can_invite_users else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„ØªÙˆØ¬ÙŠÙ‡: {'- Ù…Ù‚ÙÙ„' if locks.forward_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„Ø±ÙˆØ§Ø¨Ø·: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.link_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø³Ø¨: {'- Ù…Ù‚ÙÙ„' if locks.saap_locked else '- Ù…ÙØªÙˆØ­'}\n\n"
    
    status_message += "<b>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:</b>\n"
    status_message += f"Ø§Ù„Ø£ÙŠØ¯ÙŠ: {'- Ù…Ù‚ÙÙ„' if locks.id_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"ØµÙˆØ±ØªÙŠ: {'- Ù…Ù‚ÙÙ„' if locks.photo_cmd_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„ÙƒØ´Ù: {'- Ù…Ù‚ÙÙ„' if locks.reveal_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø¬Ù…Ø§Ù„ÙŠ: {'- Ù…Ù‚ÙÙ„' if locks.beauty_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø±ÙˆØ¨: {'- Ù…Ù‚ÙÙ„' if locks.group_info_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„ØªØ±Ø­ÙŠØ¨: {'- Ù…Ù‚ÙÙ„' if locks.welcome_locked else '- Ù…ÙØªÙˆØ­'}\n\n"
    
    # Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
    status_message += "<b>Ø§Ù„Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©:</b>\n"
    status_message += f"Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {'- Ù…Ù‚ÙÙ„' if locks.video_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„ØµÙˆØªÙŠØ§Øª: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.sound_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯: {'- Ù…Ù‚ÙÙ„' if locks.voice_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.sticker_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ù…Ù†Ø´Ù†: {'- Ù…Ù‚ÙÙ„' if locks.mention_locked else '- Ù…ÙØªÙˆØ­'}\n"
    status_message += f"Ø§Ù„ØµÙˆØ±: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.photo_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if hasattr(locks, 'channel_locked') and locks.channel_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„ÙƒÙ„Ø§ÙŠØ´: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.kalays_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø§ÙˆØ§Ù…Ø±: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if chat_id in amaerrof else '- Ù…ÙØªÙˆØ­Ø©'}\n\n"
    
    # Ø­Ø§Ù„Ø© Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ù„ØºØ§Øª
    status_message += "<b>Ø£Ù‚ÙØ§Ù„ Ø§Ù„Ù„ØºØ§Øª:</b>\n"
    status_message += f"Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.english_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„ÙØ§Ø±Ø³ÙŠØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.persian_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø¹Ø¨Ø±ÙŠØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.hebrew_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.oil_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ù‡Ù†Ø¯ÙŠØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.hindi_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø§Ø±Ù‚Ø§Ù…: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.numbers_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    status_message += f"Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: {'- Ù…Ù‚ÙÙˆÙ„Ø©' if locks.arabic_locked else '- Ù…ÙØªÙˆØ­Ø©'}\n"
    
    # Ø¥Ø¶Ø§ÙØ© ØªØ¹Ù„ÙŠÙ…Ø§Øª Ù„Ù„Ø£ÙˆØ§Ù…Ø±
    status_message += "<b>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù‚ÙÙ„ ÙˆØ§Ù„ÙØªØ­:</b>\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ù…ÙŠØ¯ÙŠØ§\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ØµÙˆØªÙŠØ§Øª\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø±ÙˆØ§Ø¨Ø·\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ØªÙˆØ¬ÙŠÙ‡\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø§ÙŠØ¯ÙŠ\n- **Ù‚ÙÙ„-ÙØªØ­** ØµÙˆØ±ØªÙŠ\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ÙƒØ´Ù\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø¬Ù…Ø§Ù„ÙŠ\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø¬Ø±ÙˆØ¨\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ØªØ±Ø­ÙŠØ¨\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ÙÙŠØ¯ÙŠÙˆ\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ØµÙˆØ±\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ù‚Ù†ÙˆØ§Øª\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ÙØ§Ø±Ø³ÙŠÙ‡\n- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ØªØ­Ù…ÙŠÙ„\n- **Ù‚ÙÙ„-ÙØªØ­** Ù‚ÙˆÙ„ÙŠ\n- **Ù‚ÙÙ„-ÙØªØ­** Ø¨ÙŠÙ‚ÙˆÙ„ Ø§ÙŠÙ‡\n"
    status_message += "- **Ù‚ÙÙ„-ÙØªØ­** Ø§Ù„ÙƒÙ„ (Ù„Ù„Ù‚ÙÙ„-Ø§Ù„ÙØªØ­ Ø§Ù„Ø´Ø§Ù…Ù„)"

    if reply_to_message_id:
        await client.send_message(
            chat_id,
            status_message,
            reply_to_message_id=reply_to_message_id,
            reply_markup=keyboard
        )
    else:
        await client.send_message(chat_id, status_message, reply_markup=keyboard)

@app.on_message(filters.command(["Ø§Ù„Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª", "Ø§Ù„Ø­Ù…Ø§ÙŠÙ‡", "Ø§Ù„Ø­Ø§Ù„Ù‡"], "") & filters.group, group=82736252)
async def show_locks_status(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID  or is_mutaw(user_id) or is_malkeen(user_id):


    
        await send_status_message(client, message.chat.id, message.id)
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")   







@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø³Ø¨", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø³Ø¨"], "") & filters.group, group=82637277647376)
async def lock_saapa(client, message): 
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID  or is_mutaw(user_id) or is_malkeen(user_id):


    
        if locks.saap_locked:
            await message.reply_text("âš ï¸ Ø§Ù„Ø³Ø¨ Ù…Ø¹Ø·Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.saap_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø³Ø¨\nà¼„")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
        
@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø³Ø¨", "ØªÙØ¹ÙŠÙ„ Ø³Ø¨"], "") & filters.group, group=2321)
async def unlock_saapa(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID  or is_mutaw(user_id) or is_malkeen(user_id):


    
        if not locks.saap_locked:
            await message.reply_text("âš ï¸ Ø§Ù„Ø³Ø¨ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            locks.saap_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø³Ø¨\nà¼„")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
        
@app.on_message(filters.text & ~filters.create(is_owner) & filters.group, group=571776)
async def delete_sapa(client, message):
    chat_id = message.chat.id
    
    locks = get_chat_locks(chat_id)
    if not locks.saap_locked:
        return
    
    member = await client.get_chat_member(chat_id, message.from_user.id)
    if member.status == ChatMemberStatus.MEMBER:
        bad_words = [
            "Ø§Ø­Ø§", "Ø®Ø®Ø®", "ÙƒØ³Ùƒ", "ÙƒØ³Ù…Ùƒ", "Ø¹Ø±Øµ", "Ø®ÙˆÙ„", "ÙŠØ¨Ù†", "ÙƒÙ„Ø¨", "Ø¹Ù„Ù‚", "ÙƒØ³Ù…", "Ø³Ø³Ø³", "ÙƒØ³Ù…ÙƒÙ…",
            "ÙŠØ§Ø¨Ù† Ù…ØªÙ†Ø§ÙƒÙ‡", "ÙŠÙ…ØªÙ†Ø§ÙƒÙ‡", "ÙŠÙ…ØªÙ†Ø§Ùƒ", "Ø¹Ø±Ø«", "Ø§Ù„Ø®ÙˆÙ„", "Ø³ÙƒØ³", "ÙƒØ³ÙŠ", "ÙƒØ³Ù… ÙÙŠØ¬Ø§", "Ø·ÙŠØ²",
            "Ù…ØªÙŠØ¸Ø²", "Ø·ÙŠØ²Ùˆ", "Ø·ÙŠØ²ÙŠ", "ØªÙŠØ²", "ØªÙŠØ²Ùƒ", "ÙƒØ³Ø³", "Ù†ÙŠÙƒ", "Ù‡Ù†ÙŠÙƒÙƒ", "Ù†ÙŠÙƒÙˆ", "Ù†ÙƒØª", "Ù†Ø§ÙƒÙƒ",
            "Ù…Ø¹ÙŠØ±Øµ", "ÙƒØ³Ù…Ø§Ùƒ", "ÙƒÙˆØ³Ùƒ", "ÙŠØ¨Ù† Ø§Ù„Ù‚Ø­Ø¨Ù‡", "Ø§Ù„Ù‚Ø­Ø¨Ù‡", "Ù…Ùƒ Ù…ØªÙ†Ø§ÙƒÙ‡", "Ø§Ù…Ùƒ ØµØ­Ø¨ØªÙŠ", "ÙŠØ§Ø¨Ù† Ø§Ù„ÙØ§Ø¬Ø±Ù‡",
            "Ø§Ù„ÙØ§Ø¬Ø±Ù‡", "Ø´Ø±Ù…ÙˆØ·Ù‡", "Ø´Ø±Ù…ÙˆØ¯", "Ø´Ø±Ù…ÙˆØ·", "ØµØ§ÙŠØ¹", "ÙƒÙ„Ø¨ÙŠ", "Ø¨Øª Ù…ØªÙ†Ø§ÙƒÙ‡", "Ø¨Øª Ø§Ù„Ù…ØªÙ†Ø§ÙƒÙ‡", "Ø§Ù„Ø¹Ø§Ù‡Ø±Ù‡",
            "Ø¨Øª ÙØ¬Ø±Ù‡", "Ø¨Øª Ø§Ù„ÙØ¬Ø±Ù‡", "ÙŠÙˆÙ„Ø§Ø¯ Ù…ØªÙ†Ø§ÙƒÙ‡", "ÙƒØ³Ù… Ø§Ù„Ù„ÙŠ ÙØ¬Ø±ÙˆØ¨", "ÙŠÙˆÙ„Ø§Ø¯ Ø§Ù„Ù‚Ø­Ø§Ø¨ÙŠ", "Ù‡Ù„Ù", "Ø­Ù„ÙˆÙ",
            "Ù…Ø¬Ù„Ø®", "Ø­Ù…Ø§Ø±", "ØªÙŠØ«", "ØªÙŠÙˆØ³", "ØªÙŠØ³", "Ø¬Ø¨Ø§Ù†", "Ø´Ø®", "Ø®Ø®Ø®Ø®", "Ø®Ù‡Ø®Ù‡Ø®Ù‡Ù‡Ù‡Ù‡", "Ø®Ø®Ø®Ø®Ø®Ø®Ø®Ù‡", "Ø·Ø±ÙŠ",
            "Ø²Ø¨ÙŠ", "ØªØ¹ Ù…ØµÙ…Øµ", "ØªØ¹Ø§Ù„ÙŠ Ù…Øµ", "Ù…ØµÙ…ØµÙ„ÙŠ ÙÙŠØ²Ø¨ÙŠ", "Ø¯Ø®Ù„Ùˆ", "Ø§Ø¯Ø®Ù„Ùˆ", "Ø§Ù†ØªØ´Ùƒ", "Ø²Ø§Ù†ÙŠ", "ÙŠØ§ Ø§Ø¨Ù† Ø§Ù„Ø²Ù†ÙŠÙ‡",
            "ÙŠØ§ Ø¨Øª Ø§Ù„Ø²Ù†ÙŠÙ‡", "ÙŠØ¨Ù† Ø²Ø§Ù†ÙŠÙ‡", "ÙŠØ¨Ù† Ø²Ù†ÙŠÙ‡", "ÙŠØ¨Øª Ø²Ø§Ù†ÙŠÙ‡", "Ø§Ù„Ø¹Ø¨ÙŠ ÙÙƒØ³Ùƒ", "Ø¸ÙŠØ²Ùƒ ÙƒØ¨ÙŠØ±Ù‡", "Ø¨Ø²Ø§Ø²Ùƒ", "Ø¨Ø²",
            "ÙƒØ³Ùˆ", "ÙƒØ³Ù…Ùˆ", "ÙƒØ³Ù…Ù‡", "ÙƒØ³Ø§Ø³", "Ø¹Ø±Ù‡", "ÙƒØ³ Ù…Ø¬Ù„Ø®", "ÙƒÙ„Ø§Ø¨ÙŠ", "ÙƒØ³Ù… ÙƒÙŠÙ…ÙŠ", "Ø¨Ø¶Ø§Ù†ÙŠ", "ØªØ¹ Ù„Ø­ÙˆØµ",
            "Ù‡ÙØ´Ø®Ùƒ", "Ù‡ÙØ´Ø®Ùˆ", "ÙØ´Ø®ØªÙˆ", "Ù‡Ù†ÙŠÙƒ Ø§Ù…Ùƒ", "Ù†ÙƒØª Ø§Ù…Ùƒ", "Ø§Ù…Ùƒ Ø§Ù„Ø´Ø±Ù…ÙˆØ·Ù‡", "Ø§Ù…Ùƒ Ù…ØªÙ†ÙƒÙ‡", "Ø§Ù…Ùƒ Ù…ØªÙ†Ø§ÙƒÙ‡",
            "Ø·ÙŠØ²Ù‡Ø§", "Ù…Ø¹ØªÙˆÙ‡", "ÙƒØ³", "Ø²Ø¨", "ÙŠØ§ Ø§Ø¨Ù† Ù…ØªÙ†Ø§Ùƒ"
        ]
        
        if any(word in message.text.lower() for word in bad_words):
            await message.delete()
            await message.reply_text(f"âŒ {message.from_user.mention} Ù…Ù…Ù†ÙˆØ¹ Ø§Ù„Ø³Ø¨ Ù‡Ù†Ø§!")



async def is_admin(message):
    if not message or not message.from_user or not message.chat:
        return False
    try:
        user = await message.chat.get_member(message.from_user.id)
        return user.privileges if user else False
    except Exception:
        return False

def detect_variables(text):
    variables = []
    if "{mention}" in text:
        variables.append("- `{mention}` : Ù…Ù†Ø´Ù† Ø§Ù„Ø¹Ø¶Ùˆ")
    if "{username}" in text:
        variables.append("- `{username}` : Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    if "{id}" in text:
        variables.append("- `{id}` : Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¹Ø¶Ùˆ")
    if "{date}" in text:
        variables.append("- `{date}` : ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…")
    if "{time}" in text:
        variables.append("- `{time}` : ÙˆÙ‚Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…")
    if "{first_name}" in text:
        variables.append("- `{first_name}` : Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„")
    if "{chat}" in text:
        variables.append("- `{chat}` : Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
    if "{admin}" in text:
        variables.append("- `{admin}` : Ø§Ø³Ù… Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø¶ÙŠÙ")
    if "{members}" in text:
        variables.append("- `{members}` : Ø¹Ø¯Ø¯ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
    return "\n".join(variables) if variables else "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ØªØºÙŠØ±Ø§Øª Ù…Ø³ØªØ®Ø¯Ù…Ø©"

def format_welcome_text(text, variables):
    formatted = text
    for key, value in variables.items():
        formatted = formatted.replace(key, value)
    
    formatted = formatted.replace("{", "\n{").replace("}", "}\n")
    formatted = "\n".join(line.strip() for line in formatted.split("\n") if line.strip())
    
    return formatted.strip()

@app.on_message(filters.command(["Ø§Ø¶Ù ØªØ±Ø­ÙŠØ¨", "ÙˆØ¶Ø¹ ØªØ±Ø­ÙŠØ¨"], "") & filters.group, group=7765)
async def set_welcome(client, message):
    try:
        if not message or not message.from_user:
            return
            
        get = await client.get_chat_member(message.chat.id, message.from_user.id)
        if (get.status in [ChatMemberStatus.OWNER] or 
            is_owner(None, None, message) or 
            is_moteerr(message.from_user.id) or 
            is_mutaw(message.from_user.id) or  
            is_malkeen(message.from_user.id) or 
            is_admann(message.from_user.id)):
            
            if len(message.command) < 2:
                return await message.reply(
                    "ğŸ“ **Ø·Ø±ÙŠÙ‚Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø±:**\n"
                    "`.Ø§Ø¶Ù ØªØ±Ø­ÙŠØ¨` ÙŠÙ„ÙŠÙ‡Ø§ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª\n\n"
                    "**Ù…Ø«Ø§Ù„:**\n"
                    "`Ø§Ø¶Ù ØªØ±Ø­ÙŠØ¨ Ù…Ø±Ø­Ø¨Ø§ Ø¹Ø²ÙŠØ²ÙŠ\nØ§Ù„Ø§Ø³Ù…: {mention}\nØ§Ù„Ù…Ø¹Ø±Ù: {username}\n"
                    "Ø§Ù„Ø£ÙŠØ¯ÙŠ: {id}\nØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…: {date}\nÙˆÙ‚Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…: {time}\n"
                    "Ø§Ø³Ù…Ù‡: {first_name}\nØ§Ù„Ø¬Ø±ÙˆØ¨: {chat}\nØ§Ù„Ù…Ø¶ÙŠÙ: {admin}\nØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡: {members}`\n\n"
                    "Ù‚Ù… Ø¶ØºØ· Ù„Ù„Ù†Ø³Ø®:\n\n"
                    "**Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:**\n"
                    "- `{mention}` : Ù…Ù†Ø´Ù† Ø§Ù„Ø¹Ø¶Ùˆ\n"
                    "- `{username}` : Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\n"
                    "- `{id}` : Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¹Ø¶Ùˆ\n"
                    "- `{date}` : ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…\n"
                    "- `{time}` : ÙˆÙ‚Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…\n"
                    "- `{first_name}` : Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„\n"
                    "- `{chat}` : Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©\n"
                    "- `{admin}` : Ø§Ø³Ù… Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø¶ÙŠÙ\n"
                    "- `{members}` : Ø¹Ø¯Ø¯ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©"
                )
            
            welcome_text = message.text.split(" ", 1)[1] if len(message.command) > 1 else ""
            welcome_messages[str(message.chat.id)] = welcome_text
            
            variables = {
                "{mention}": "ğŸ‘‰ [Ù…Ø°ÙƒÙˆØ± Ø§Ù„Ø¹Ø¶Ùˆ]",
                "{username}": "ğŸ‘‰ Ø§Ù„Ù…Ø¹Ø±Ù",
                "{id}": "ğŸ‘‰ Ø§Ù„Ø£ÙŠØ¯ÙŠ",
                "{date}": "ğŸ‘‰ Ø§Ù„ØªØ§Ø±ÙŠØ®",
                "{time}": "ğŸ‘‰ Ø§Ù„ÙˆÙ‚Øª",
                "{first_name}": "ğŸ‘‰ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„",
                "{chat}": "ğŸ‘‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©",
                "{admin}": "ğŸ‘‰ Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø¶ÙŠÙ",
                "{members}": "ğŸ‘‰ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡"
            }
            
            formatted_welcome = format_welcome_text(welcome_text, variables)
            
            await message.reply(
                f"âœ… **ØªÙ… ØªØ­Ø¯ÙŠØ« Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ù†Ø¬Ø§Ø­**\n\n"
                f"ğŸ“œ **Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:**\n"
                f"{formatted_welcome}\n\n"
                f"ğŸ‘¤ **Ø¨ÙˆØ§Ø³Ø·Ø©:** {message.from_user.mention if message.from_user else 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\n"
                f"ğŸ“… **Ø§Ù„ØªØ§Ø±ÙŠØ®:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
        else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³\nà¼„")
    except Exception as e:
        await message.reply(f"Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")

@app.on_message(filters.command(["Ù…Ø³Ø­ ØªØ±Ø­ÙŠØ¨", "Ø­Ø°Ù ØªØ±Ø­ÙŠØ¨"], "") & filters.group, group=7766)
async def delete_welcome(client, message):
    try:
        if not message or not message.from_user:
            return
            
        get = await client.get_chat_member(message.chat.id, message.from_user.id)
        if (get.status in [ChatMemberStatus.OWNER] or 
            is_owner(None, None, message) or 
            is_moteerr(message.from_user.id) or 
            is_mutaw(message.from_user.id) or  
            is_malkeen(message.from_user.id) or 
            is_admann(message.from_user.id)):
        
            if str(message.chat.id) in welcome_messages:
                del welcome_messages[str(message.chat.id)]
                await message.reply("âœ… ØªÙ… Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ù†Ø¬Ø§Ø­")
            else:
                await message.reply("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù…Ø¶Ø¨ÙˆØ·Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
        else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³\nà¼„")        
    except Exception as e:
         await message.reply(f"Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")

@app.on_message(filters.command("Ø§Ù„ØªØ±Ø­ÙŠØ¨Ø§Øª", "") & filters.group, group=7767)
async def welcome_status(client, message):
    try:
        if not message or not message.from_user:
            return
            
        get = await client.get_chat_member(message.chat.id, message.from_user.id)
        if (get.status in [ChatMemberStatus.OWNER] or 
            is_owner(None, None, message) or 
            is_moteerr(message.from_user.id) or 
            is_mutaw(message.from_user.id) or  
            is_malkeen(message.from_user.id) or 
            is_admann(message.from_user.id)):
        
            chat_id = str(message.chat.id)
            status = "âœ… Ù…ÙØ¹Ù„" if chat_id in welcome_messages else "âŒ Ù…Ø¹Ø·Ù„"
            current_message = welcome_messages.get(chat_id, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù…Ø¶Ø¨ÙˆØ·Ø©")
        
            variables_used = detect_variables(current_message)
        
            await message.reply(
                f"ğŸ“Š **Ø­Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨Ø§Øª:**\n"
                f"- Ø§Ù„Ø­Ø§Ù„ï¿½ï¿½: {status}\n"
                f"- Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: {message.chat.title if message.chat else 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\n\n"
                f"ğŸ“œ **Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø§Ù„Ø­Ø§Ù„ÙŠØ©:**\n"
                f"{current_message}\n\n"
                f"ğŸ”£ **Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©:**\n"
                f"{variables_used}\n\n"
                f"ğŸ“… Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
        else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³\nà¼„")
    except Exception as e:
        await message.reply(f"Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")

@app.on_message(filters.new_chat_members & filters.group, group=544)
async def welcome_new_member(client, message):
    try:
        if not message or not message.chat:
            return
            
        if welcome_locked or message.chat.id in disabled_chats:
            return
        
        chat = message.chat
        now = datetime.now()
        members_count = await client.get_chat_members_count(chat.id)
        
        for user in message.new_chat_members:
            if user.is_bot:
                continue
                
            mention_link = f"[{user.first_name}](tg://user?id={user.id})" if user else "Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯"
            admin_name = message.from_user.first_name if message.from_user else "Ø§Ù„Ù†Ø¸Ø§Ù…"
            admin_link = f"[{admin_name}](tg://user?id={message.from_user.id})" if message.from_user and message.from_user.id else "Ø§Ù„Ù†Ø¸Ø§Ù…"
            username_display = f"@{user.username}" if user and user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù"
            
            variables = {
                "{mention}": mention_link,
                "{username}": username_display,
                "{id}": str(user.id) if user else "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
                "{date}": now.strftime("%Y-%m-%d"),
                "{time}": now.strftime("%H:%M:%S"),
                "{first_name}": user.first_name if user else "Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯",
                "{chat}": chat.title if chat else "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©",
                "{admin}": admin_link,
                "{members}": str(members_count)
            }
            
            profile_button = [
                [InlineKeyboardButton(
                    user.first_name if user else "Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯", 
                    url=f"https://t.me/{user.username}" if user and user.username else "https://t.me"
                )]
            ] if user else None
            
            welcome_text = welcome_messages.get(str(chat.id), 
                "Ù„Ø§ ØªÙØ³ÙØ¦ Ø§Ù„Ù„ÙØ¸ ÙˆØ¥Ù† Ø¶ÙØ§Ù‚ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø±ÙÙ‘Ø¯\n\n"
                "**É´á´§á´á´‡ âŒ¯** {mention}\n"
                "**á´œÑ•á´‡ê›É´á´§á´á´‡ âŒ¯** {username}\n"
                "**Date âŒ¯** {date}"
            )
            
            formatted_welcome = format_welcome_text(welcome_text, variables)
            
            await message.reply(
                formatted_welcome,
                reply_markup=InlineKeyboardMarkup(profile_button) if profile_button else None,
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.MARKDOWN
            )
 
    except Exception as e:
        print(f"Error in welcome: {str(e)}")


@app.on_message(filters.left_chat_member & filters.group, group=222307)
async def send_leave_message(client: Client, message: Message):
    try:
        usr = await client.get_chat(message.from_user.id)
        name = usr.first_name
        chat_id = message.chat.id
        await app.send_message(chat_id=chat_id, text=f"ÙˆÙØ£ÙÙ† Ù„ÙÙ‘ÙŠÙ’Ø³Ù Ù„ÙÙ„Ù’Ø¥ÙÙ†Ø³ÙØ§Ù†Ù Ø¥ÙÙ„ÙÙ‘Ø§ Ù…ÙØ§ Ø³ÙØ¹ÙÙ‰Ù°\n **É´á´§á´á´‡ âŒ¯** {message.from_user.mention}\ná´œÑ•á´‡ê›É´á´§á´á´‡ âŒ¯ @{message.from_user.username}")
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø§Ø¡ Ø§Ø³Ù†Ø§Ø¡ Ù…ØºØ§Ø¯Ø±Ù‡: {str(e)}")
        
        
        
        
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ ÙˆØ§Ù„Ù…Ù…ÙŠØ²Ø©
# â”ˆâ”…â”…â”â”â”âŠ·âŠ°ğŸ¤âŠ±âŠ¶â”â”â”â”…â”…â”ˆ

async def edit_message_with_retry(query, text, reply_markup=None):
    try:
        await query.edit_message_text(
            text=text,
            reply_markup=reply_markup
        )
    except FloodWait as e:
        await asyncio.sleep(e.value)
        await edit_message_with_retry(query, text, reply_markup)
    except MessageNotModified:
        pass
    except Exception as e:
        print(f"Error editing message: {e}")



user = None
user_command_state = {}

@app.on_message(filters.command(["Ø§Ù„Ø§ÙˆØ§Ù…Ø±", "Ø§ÙˆØ§Ù…Ø±", "/Commands"], "") & filters.group, group=726272728281)
async def show_commands_menu(client, message):
    global user, user_command_state  # Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø£Ù†Ù†Ø§ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
    chat_id = message.chat.id
    
    if chat_id in amaerrof:
        return await message.reply_text("Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ù…Ø¹Ø·Ù„Ù‡ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†\nà¼„")
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        
        # ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª
        user = message.from_user.id
        user_command_state[message.from_user.id] = {"chat_id": chat_id}
        
        await message.reply_video(
            video="https://graph.org/file/7ea7cf24b9536256880ad.mp4",
            caption=f"<b>{app.mention}\nâ€¢ Ù…Ù€Ø±Ø­Ù€Ø¨Ù€Ø§ Ø¨Ù€Ùƒ: {message.from_user.mention()}\nâ€¢ Ø¨Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ùˆ ØªØ­ÙƒÙ… Ø§Ù„Ø®Ø§ØµØ© Ø¨ÙŠ</b>",
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton("ğŸ”’ Ø­Ù…Ø§ÙŠØ©", callback_data="lockdd"),
                        InlineKeyboardButton("ğŸ”Š Ø¥Ø¯Ø§Ø±Ø©", callback_data="abimnn"),
                        InlineKeyboardButton("ğŸµ Ù…ÙˆØ³ÙŠÙ‚Ù‰", callback_data="playyy"),
                    ],
                    [
                        InlineKeyboardButton("ğŸ” Ø¨Ø­Ø«", callback_data="deeev"),
                    ],
                    [
                        InlineKeyboardButton("ğŸ® Ø£Ù„Ø¹Ø§Ø¨", callback_data="gamess"),
                        InlineKeyboardButton("âœ¨ Ø§Ù„Ù…Ø·ÙˆØ± Ù…Ù…ÙŠØ²Ø©", callback_data="extra_cmds"),
                    ],
                    [        
                        InlineKeyboardButton("ğŸ–‡ï¸ Ù…Ù…ÙŠØ²Ø©", callback_data="cmdds2"),
                    ],
                ]
            )
        )
    else:
            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
            
            
@app.on_callback_query(filters.regex("Musicvega"), group=1863738666666655582)
async def return_to_main_menu(client, query: CallbackQuery):
    global user, user_command_state
    user_id = query.from_user.id
    
    chat = query.message.chat if query.message else None
    
    if not chat or chat.type not in {enums.ChatType.GROUP, enums.ChatType.SUPERGROUP}:
        return await client.answer_callback_query(query.id, text="Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·!", show_alert=True)
    
    if user_id not in user_command_state:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = f"""{app.mention}\nâ€¢ Ù‡Ø°Ù‡ Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø®Ø§ØµÙ‡ Ù€Ù…Ù† ÙÙŠØ¬Ø§\nâ€¢ Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ùˆ Ø§Ù„Ø¨ÙˆØª"""
    reply_markup = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("ğŸ”’ Ø­Ù…Ø§ÙŠØ©", callback_data="lockdd"),
                InlineKeyboardButton("ğŸ”Š Ø¥Ø¯Ø§Ø±Ø©", callback_data="abimnn"),
                InlineKeyboardButton("ğŸµ Ù…ÙˆØ³ÙŠÙ‚Ù‰", callback_data="playyy"),
            ],
            [
                InlineKeyboardButton("ğŸ” Ø¨Ø­Ø«", callback_data="deeev"),
            ],
            [
                InlineKeyboardButton("ğŸ® Ø£Ù„Ø¹Ø§Ø¨", callback_data="gamess"),
                InlineKeyboardButton("âœ¨ Ù„Ù„Ù…Ø·ÙˆØ± Ù…Ù…ÙŠØ²Ø©", callback_data="extra_cmds"),
            ],
            [        
                InlineKeyboardButton("ğŸ–‡ï¸ Ù…Ù…ÙŠØ²Ø© ", callback_data="cmdds2"),
            ],
        ]
    )
    
    await edit_message_with_retry(query, text, reply_markup)



@app.on_callback_query(filters.regex("playyy"), group=14)
async def playyy(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b>ğŸµ Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ´ØºÙŠÙ„ ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª:

â€¢ Ø´ØºÙ„ (Ù…Ø¹ Ø§Ù„Ø§Ø³Ù… Ø§Ùˆ Ø±Ø¯)
â€¢ ÙÙŠØ¯ÙŠÙˆ (Ù„Ù„Ø¨Ø« Ø§Ùˆ Ø¹Ø§Ø¯ÙŠ)
â€¢ Ø¨Ø« Ù…Ø¨Ø§Ø´Ø± (Ø±Ø§Ø¨Ø· Ø§Ùˆ Ø§Ø³Ù…)
â€¢ Ø§ÙŠÙ‚Ø§Ù (Ù„Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø§ØºÙ†ÙŠÙ‡)
â€¢ ÙˆÙ‚Ù (Ù„Ø§ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª)
â€¢ ØªØ®Ø·ÙŠ (Ù„Ø§ØºÙ†ÙŠÙ‡ Ø§Ù„ØªØ§Ù„ÙŠØ©)
â€¢ ÙƒÙ…Ù„ (Ù„Ø§ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø¤Ù‚Øª)
â€¢ Ù‚Ø¯Ù… (Ù…Ø¹ Ø¹Ø¯Ø¯ Ø«ÙˆØ§Ù†ÙŠ)
â€¢ Ø±Ø¬ÙˆØ¹ (Ù…Ø¹ Ø¹Ø¯Ø¯ Ø«ÙˆØ§Ù†ÙŠ)
â€¢ ØªÙƒØ±Ø§Ø± (Ù…Ø¹ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø§Øª)
â€¢ Ù…ÙŠÙ† ÙÙŠ Ø§Ù„ÙƒÙˆÙ„
â€¢ ÙØªØ­ Ø§Ù„ÙƒÙˆÙ„ (Ù„ÙØªØ­ Ù…Ø­Ø§Ø¯Ø«Ù‡)
â€¢ Ù‚ÙÙ„ Ø§Ù„ÙƒÙˆÙ„ (Ù„Ù‚ÙÙ„ Ù…Ø­Ø§Ø¯Ø«Ù‡<blockquote>)
â‡œØªÙ†ÙˆÙŠÙ‡: Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ÙˆØ§Ù…Ø± ØªØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„ØºÙ‡ Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡ Ø£ÙŠØ¶Ø§Ù‹</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)

@app.on_callback_query(filters.regex("lockdd"), group=120517665581)
async def lockdd(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b><u>ğŸ”’ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù‚ÙÙ„ ÙˆØ§Ù„ÙØªØ­ Ù„Ù„Ø­Ù…Ø§ÙŠØ©:</u>\n
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªÙˆØ¬ÙŠÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØµÙˆØ±)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙÙŠØ¯ÙŠÙˆ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù…ÙŠØ¯ÙŠØ§)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙƒÙ„Ø§ÙŠØ´)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø³Ø¨)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªØ¹Ø¯ÙŠÙ„)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªÙƒØ±Ø§Ø±)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø±ÙˆØ§Ø¨Ø·)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù…Ù†Ø´Ù†)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ø´Ø¹Ø§Ø±Ø§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø¨ÙˆØªØ§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ø¶Ø§ÙÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§ÙˆØ§Ù…Ø±)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù…Ù„ÙØ§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø¯Ø¹ÙˆØ©)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªØ«Ø¨ÙŠØª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØµÙˆØªÙŠØ§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø±ÙŠÙƒÙˆØ±Ø¯)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù‚Ù†ÙˆØ§Øª)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø¹Ø±Ø¨ÙŠÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù‡Ù†Ø¯ÙŠÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙØ§Ø±Ø³ÙŠØ©)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ø±Ù‚Ø§Ù…)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªÙ„ÙŠØ«ÙˆÙ†)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø¹Ø¨Ø±ÙŠÙ‡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªØ±Ø­ÙŠØ¨)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§ÙŠØ¯ÙŠ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙƒØ´Ù)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (ØµÙˆØ±ØªÙŠ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø¬Ù…Ø§Ù„ÙŠ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø¨Ø§ÙŠÙˆ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙŠÙˆØªÙŠÙˆØ¨)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªØ­Ù…ÙŠÙ„)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ø²ÙƒØ§Ø±)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù†Ø¯Ø§Ø¡)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ØªØ§Ùƒ)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„Ø§Ù„Ø¹Ø§Ø¨)
â€¢ Ù‚ÙÙ„ Ùˆ ÙØªØ­ (Ø§Ù„ÙƒÙ„)
â‡œØªÙ†ÙˆÙŠÙ‡: Ø¨Ø¹Ø¶ Ø§Ù„Ø§ÙˆØ§Ù…Ø± ØªØ¹Ù…Ù„ Ø¨Ù€(ØªÙØ¹ÙŠÙ„ Ùˆ ØªØ¹Ø·ÙŠÙ„)</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)

@app.on_callback_query(filters.regex("abimnn"), group=119340009986)
async def abinmnn(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b>ğŸ”Š<u> Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙˆØ§Ù„ØªØ­ÙƒÙ…:</u>

â€¢ ØªÙ‚ÙŠÙŠØ¯ (Ø§Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ‚ÙŠØ¯)
â€¢ Ø­Ø¸Ø± (Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¸Ø±)
â€¢ ÙƒØªÙ… (Ø§Ù„ØºØ§Ø¡ ÙƒØªÙ…)
â€¢ Ø·Ø±Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª
â€¢ ÙƒØ´Ù Ø§Ù„Ø¨ÙˆØªØ§Øª
â€¢ Ù…Ù†Ø¹ Ùˆ Ø§Ù„ØºØ§Ø¡ Ù…Ù†Ø¹ (Ù…Ø¹ Ø§Ù„ÙƒÙ„Ù…Ù‡)

<u>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø±ÙØ¹ ÙˆØ§Ù„ØªÙ†Ø²ÙŠÙ„:</u>

â€¢ Ø±ÙØ¹ Ù…Ø¯ÙŠØ± (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ù…Ø§Ù„Ùƒ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø§Ø¯Ù…Ù† (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ù…Ø·ÙˆØ± (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ù…Ø´Ø±Ù (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)

<u>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…:</u>

â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙƒØªÙˆÙ…ÙŠÙ†: (Ø§Ù„Ù…ÙƒØªÙˆÙ…ÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: (Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù‚ÙŠØ¯ÙŠÙ†: (Ø§Ù„Ù…Ù‚ÙŠØ¯ÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¯Ø±Ø¨ÙŠÙ†: (Ø§Ù„Ù…Ø¯Ø±Ø§Ø¡)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†: (Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø§Ù„ÙƒÙŠÙ†: (Ø§Ù„Ù…Ø§Ù„ÙƒÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†: (Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ø¯Ù…Ù†ÙŠÙ‡: (Ø§Ù„Ø§Ø¯Ù…Ù†ÙŠÙ‡)
â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø§Øª (Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø§Øª 
)
<u>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø³Ø­:</u>

â€¢ Ù…Ø³Ø­ Ø§Ù„Ø§Ø¯Ù…Ù†ÙŠÙ‡
â€¢ Ù…Ø³Ø­ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
â€¢ Ù…Ø³Ø­ Ø§Ù„Ù…ÙƒØªÙˆÙ…ÙŠÙ†
â€¢ Ù…Ø³Ø­ Ø§Ù„Ù…Ù‚ÙŠØ¯ÙŠÙ†
â€¢ Ù…Ø³Ø­ Ø§Ù„Ù…Ø§Ù„ÙƒÙŠÙ†
â€¢ Ù…Ø³Ø­ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†
â€¢ Ù…Ø³Ø­ Ø§Ù„Ø±ØªØ¨</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)



@app.on_callback_query(filters.regex("gamess"), group=1445687746)
async def gamess(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b>ğŸ® <u>Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ ÙˆØ§Ù„ØªØ³Ø§Ù„ÙŠ:</u>

â€¢ Ø§Ù„Ø¨Ù†Ùƒ
â€¢ Ù„ÙˆØ®ÙŠØ±ÙˆÙƒ
â€¢ ÙƒØª
â€¢ ØªÙˆÙŠØª
â€¢ Ù†ÙƒØªÙ‡
â€¢ Ø§Ù‚ØªØ¨Ø§Ø³
â€¢ Ù…ØªØ­Ø±ÙƒÙ‡
â€¢ Ø§Ù†ØµØ­Ù†ÙŠ
â€¢ ØµØ±Ø§Ø­Ù‡
â€¢ Ø§Ø­ÙƒØ§Ù…
â€¢ Ø§Ù„Ø§Ø¹Ø¨ÙŠÙ†
â€¢ Ø§ÙÙ„Ø§Ù…
â€¢ Ù…Ø·Ø±Ø¨ÙŠÙ†
â€¢ Ø§Ø¹Ù„Ø§Ù…
â€¢ Ù…Ø´Ø§Ù‡ÙŠØ±
â€¢ ØªØ±ØªÙŠØ¨
â€¢ Ø§Ù„Ù†ÙˆØ§Ø¯ÙŠ
â€¢ Ù‚ÙˆÙ„ÙŠ
â€¢ ÙˆÙŠØ´ ÙŠÙ‚ÙˆÙ„
â€¢ Ù†Ø³Ø¨Ù‡ Ø§Ù„ØºØ¨Ø§Ø¡
â€¢ Ù†Ø³Ø¨Ù‡ Ø§Ù„Ø­Ø¨
â€¢ Ù†Ø³Ø¨Ù‡ Ø§Ù„Ø±Ø¬ÙˆÙ„Ù‡
â€¢ Ù†Ø³Ø¨Ù‡ Ø§Ù„Ø§Ù†ÙˆØ«Ù‡
â€¢ ÙˆØ´ ÙŠÙ‚ÙˆÙ„
â€¢ Ø±Ùˆ
â€¢ ØºÙ†ÙŠÙ„ÙŠ
â€¢ Ù…Ù‡Ù†ØªÙŠ 
â€¢ Ù‡ÙƒØ±Ùˆ
â€¢ Ù‚ØªÙ„ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ù…Ø­ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ ØªÙ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)

â€¢ Ø±ÙØ¹ ÙƒÙ„Ø¨ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø­Ù…Ø§Ø± (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø¨Ù‚Ø±Ù‡ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ù‚Ø±Ø¯ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ ØªÙŠØ³ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø®Ø±ÙˆÙ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø®Ù†Ø²ÙŠØ± (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ù†Ø³Ù†Ø§Ø³ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)
â€¢ Ø±ÙØ¹ Ø±Ù‚Ø§ØµÙ‡ (Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯)</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)

@app.on_callback_query(filters.regex("deeev"), group=777)
async def deeeeev(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """
<b>ğŸ” <u>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª:</u>


â€¢ Ø¨Ø­Ø« (Ù…Ø¹ Ø§Ù„Ø§Ø³Ù…)
â€¢ ÙŠÙˆØªÙŠÙˆØ¨ (Ù…Ø¹ Ø§Ù„Ø§Ø³Ù…)
â€¢ ÙŠÙˆØª (Ù…Ø¹ Ø§Ù„Ø§Ø³Ù…)
â€¢ Ø§Ù„Ø§ÙŠØ¯ÙŠ
â€¢ Ø¬Ù…Ø§Ù„ÙŠ
â€¢ ØµÙˆØ±ØªÙŠ
â€¢ Ø¬Ø±ÙˆØ¨
â€¢ ØµÙˆØ±Ù†ÙŠ
â€¢ ÙƒØ´Ù
â€¢ ØµÙ„Ø§Ø­ÙŠØ§ØªÙ‡ 
â€¢ ØµÙ„Ø§Ø­ÙŠØ§ØªÙŠ
â€¢ Ù„Ù‚Ø¨Ù‡
â€¢ Ø²Ø®Ø±ÙÙ‡
â€¢ Ù„Ù‚Ø¨ÙŠ
â€¢ Ø§Ø¶Ù Ø±Ø¯
â€¢ Ø­Ø°Ù Ø±Ø¯
â€¢ Ø§Ù„Ø±Ø¯ÙˆØ¯
â€¢ Ø§Ø¶Ù Ø±Ø¯ Ø¹Ø§Ù…
â€¢ Ø­Ø°Ù Ø±Ø¯ Ø¹Ø§Ù…
â€¢ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù…
â€¢ Ù‡Ù…Ø³Ù‡ (Ø§Ù‡Ù…Ø³ Ø¨Ø§Ù„Ø±Ø¯)
â€¢ ØªÙ„Ø¬Ø±Ø§Ù Ù…ÙŠØ¯ÙŠØ§ (ÙØ¯ÙŠÙˆ Ø§Ùˆ ØµÙˆØ±Ù‡)
â€¢ Ø§Ø³ØªÙƒ (Ø¨Ø§Ù„Ø±Ø¯ Ù„Ù„Ø§Ø³ØªÙŠÙƒØ±)
â€¢ ØªØ­ÙˆÙŠÙ„ Ù„ØµÙˆØ±Ù‡ (Ø¨Ø§Ù„Ø±Ø¯ Ù„Ù„Ø§Ø³ØªÙŠÙƒØ±)
â€¢ ØªØ«Ø¨ÙŠØª Ùˆ Ø§Ù„ØºØ§Ø¡ Ø§Ù„ØªØ«Ø¨ÙŠØª (Ø¨Ø§Ù„Ø±Ø¯)
â€¢ Ø±Ø§Ø¨Ø· (ÙŠØ¬Ù„Ø¨ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡)
â€¢ Ù…Ø³Ø­ (Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ø§Ù„Ø±Ø³Ø§Ù„Ù‡)
â€¢ ØªÙ†Ø¸ÙŠÙ (ÙŠÙ†Ø¸Ù Ø¯Ø±Ø¯Ø´Ø© ÙƒÙ„Ù‡Ø§)
â€¢ ÙØ­Øµ Ø§Ù„Ø¬Ø±ÙˆØ¨ (ÙŠØ¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡Ø§)
â€¢ ØªÙØ¹ÙŠÙ„ Ø¨Ø§ÙŠÙˆ (Ù„ÙˆØ¶Ø¹ Ø³Ø§Ø¹Ø© Ø¨Ø§Ù„Ø¨Ø§ÙŠÙˆ)
â€¢ ØªÙØ¹ÙŠÙ„ Ø³Ø§Ø¹Ù‡ Ø§Ù„Ø­Ø±ÙˆØ¨ (Ù„ÙˆØ¶Ø¹ Ø³Ø§Ø¹Ù‡ Ù„Ù„Ø§Ø³Ù…)</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)
    
@app.on_callback_query(filters.regex("cmdds2"), group=777)
async def deeeeevcmdds2(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b><u>âœ¨ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ù…ÙŠØ²Ø© Ù„Ù„Ù…Ø·ÙˆØ±</u>

â€¢ Ø§Ù„ØªØ±ÙˆÙŠØ¬
â€¢ ØªØºÙŠØ± ÙƒÙ„ÙŠØ´Ø© Ø§Ù„Ø³ÙˆØ±Ø³
â€¢ ØªØºÙŠØ± Ø²Ø± Ø§Ù„Ø³ÙˆØ±Ø³
â€¢ ØªØºÙŠØ± Ù„ÙˆØ¬Ùˆ Ø§Ù„Ø³ÙˆØ±Ø³
â€¢ Ø­Ø°Ù ØªØ®ØµÙŠØµ Ø§Ù„Ø³ÙˆØ±Ø³
â€¢ ØªØºÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ø³ØªØ§Ø±Øª
â€¢ Ø­Ø°Ù Ø±Ø³Ø§Ù„Ù‡ Ø§Ø³ØªØ§Ø±Øª
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ø³ØªØ§Ø±Øª
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ø³ØªØ§Ø±Øª

â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„Ø¬Ø±ÙˆØ¨Ø§Øª
â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„Ù‚Ù†ÙˆØ§Øª
â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ø¨Ø§Ù„Ø«Ø¨ÙŠØª 
â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„Ù…Ø³Ø®Ø¯Ù…ÙŠÙ†

â€¢ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ:
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¹Ø§Ù…: 
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¹Ø§Ù…: 
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø±Ø§ÙŠÙØª: 
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø±Ø§ÙŠÙØª: 
â€¢ Ø§Ø¶Ù Ù‚Ù†Ø§Ù‡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„ØªØ´ØºÙŠÙ„: 
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„ØªØ´ØºÙŠÙ„: 
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„ØªØ´ØºÙŠÙ„: 
â€¢ Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: 
â€¢ Ø­Ø°Ù Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ 
â€¢ ÙØ­Øµ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯: 
â€¢ Ø§Ø¶Ù Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø§ÙˆÙ„: 
â€¢ Ø§Ø²Ø§Ù„Ø© Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø§ÙˆÙ„: 
â€¢ ØªØºÙŠØ± ÙŠÙˆØ²Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯: 
â€¢ Ø§Ø¶Ù Ø¨Ø§ÙŠÙˆ 
â€¢ Ø§Ø²Ø§Ù„Ø© Ø¨Ø§ÙŠÙˆ 
â€¢ Ø§Ø¶Ù Ø§Ù„Ø§Ø³Ù… Ø§Ù„ØªØ§Ù†ÙŠ 
â€¢ Ø§Ø²Ø§Ù„Ø© Ø§Ù„Ø§Ø³Ù… Ø§Ù„ØªØ§Ù†ÙŠ 
â€¢ Ø§Ø¶Ù ØµÙˆØ±Ù‡ 
â€¢ Ø§Ø²Ø§Ù„Ø© ØµÙˆØ±Ù‡ 
â€¢ Ø§Ø²Ø§Ù„Ø© ÙƒÙ„ Ø§Ù„ØµÙˆØ± 
</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)
    
@app.on_callback_query(filters.regex("extra_cmds"), group=776557)
async def deeeeeextra_cmdsv(client, query: CallbackQuery):
    global user
    chat = query.message.chat
    get = await client.get_chat_member(chat.id, query.from_user.id)
    if query.from_user.id != user:
        await client.answer_callback_query(query.id, text="Ù‡ÙŠÙŠÙ‡ Ù…Ø§ÙŠÙ…Ø¯ÙŠÙƒ Ø§Ù„Ø§Ù…Ø± ÙŠØ§Ø±ÙˆØ¹Ù‡!!", show_alert=True)
        return

    await client.answer_callback_query(query.id)
    
    text = """<b>â›“ï¸â€ğŸ’¥<u>Ø§ÙˆØ§Ù…Ø± Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø·ÙˆØ±</u>\n
â€¢ Ø±ÙØ¹ Ù…Ø·ÙˆØ± 
â€¢ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† 
â€¢ ØºØ§Ø¯Ø± Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª 
â€¢ ØºØ§Ø¯Ø± Ø§Ù„Ù‚Ù†ÙˆØ§Øª 
â€¢ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙ†ØµÙŠØ¨ 
â€¢ ÙØ­Øµ Ø§Ù„Ø¨ÙˆØª 
â€¢ Ø³Ø±Ø¹Ù‡ Ø§Ù„Ø¨ÙˆØª 
â€¢ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙˆØª 
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙˆØ§ØµÙ„
â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª 
â€¢ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† 
â€¢ Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª 
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…ÙŠÙˆØ²Ùƒ Ø¹Ø§Ù…
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…ÙŠÙˆØ²Ùƒ Ø¹Ø§Ù…
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ø§Ù…
â€¢ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ø§Ù…
â€¢ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³Ø§Ø¹Ø© : Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø³Ø§Ø¹Ø© : Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ ØªØºÙŠØ± Ø®Ø· Ø§Ù„Ø³Ø§Ø¹Ù‡: Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ ØªØºÙŠØ± Ø±Ù…Ø² Ø§Ù„Ø³Ø§Ø¹Ù‡ : Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ : Ù„Ù…Ø¹Ø±ÙÙ‡ Ù…Ø³Ø§Ø¹Ø¯ ÙŠØ¹Ù…Ù„ 
â€¢ ØºØ§Ø¯Ø± Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª : Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ ØºØ§Ø¯Ø± Ø§Ù„Ù‚Ù†ÙˆØ§Øª : Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ø¨ØªÙˆØ¬ÙŠÙ‡ Ø¨Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ Ø§Ø°Ø§Ø¹Ù‡ Ø¨Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ 
â€¢ ØªØ¹ÙŠÙ† Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª 
â€¢ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³Ø¬Ù„ 
â€¢ Ø§Ù„Ù†Ø³Ø®Ù‡ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©:
â€¢ Ø¬Ù„Ø¨ Ù†Ø³Ø®Ù‡ Ù„Ù„Ø¬Ø±ÙˆØ¨Ø§Øª
â€¢ Ø±ÙØ¹ Ù†Ø³Ø®Ù‡ Ù„Ù„Ø¬Ø±ÙˆØ¨Ø§Øª
â€¢ Ø¬Ù„Ø¨ Ù†Ø³Ø®Ù‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
â€¢ Ø±ÙØ¹ Ù†Ø³Ø®Ù‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: 
â€¢ Ø±ÙØ¹ Ù†Ø³Ø®Ù‡ Ù„Ù„Ù‚Ù†ÙˆØ§Øª 
â€¢ Ø¬Ù„Ø¨ Ù†Ø³Ø®Ù‡ Ù„Ù„Ù‚Ù†ÙˆØ§Øª</b>"""
    
    reply_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Ë¹â»Ù°", callback_data="Musicvega")]]
    )
    
    await edit_message_with_retry(query, text, reply_markup)
    
    
    
    


# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø© (Ø³ÙŠØªÙ… ØªØ®Ø²ÙŠÙ†Ù‡Ø§ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©)
banned_words = {}
# Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ÙŠØ·Ù„Ø¨ÙˆÙ† Ø¥Ø¶Ø§ÙØ© ÙƒÙ„Ù…Ø© Ù…Ù…Ù†ÙˆØ¹Ø©
waiting_for_word = {}

@app.on_message(filters.command("Ù…Ù†Ø¹", "") & filters.group, group=55555557)
async def ban_word_command(client, message):
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø£Ø¯Ù…Ù† Ø£Ùˆ Ø£Ø¹Ù„Ù‰)
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or 
        is_owner(None, None, message) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        
        # Ø·Ù„Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ„Ù…Ø©
        await message.reply_text("ğŸ“ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ù…Ù†Ø¹Ù‡Ø§")
        # ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ÙŠØ·Ù„Ø¨ Ø¥Ø¶Ø§ÙØ© ÙƒÙ„Ù…Ø©
        waiting_for_word[message.from_user.id] = {
            "chat_id": message.chat.id,
            "type": "ban"
        }
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("Ø§Ù„ØºØ§Ø¡ Ù…Ù†Ø¹", "") & filters.group, group=54333333)
async def unban_word_command(client, message):
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø£Ø¯Ù…Ù† Ø£Ùˆ Ø£Ø¹Ù„Ù‰)
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or 
        is_owner(None, None, message) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        
        # Ø·Ù„Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ„Ù…Ø©
        await message.reply_text("ğŸ“ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ù„ØºØ§Ø¡ Ù…Ù†Ø¹Ù‡Ø§")
        # ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ÙŠØ·Ù„Ø¨ Ø¥Ø²Ø§Ù„Ø© ÙƒÙ„Ù…Ø©
        waiting_for_word[message.from_user.id] = {
            "chat_id": message.chat.id,
            "type": "unban"
        }
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø¹", "") & filters.group, group=5372)
async def banned_words_list(client, message):
    chat_id = str(message.chat.id)
    
    if chat_id in banned_words and banned_words[chat_id]:
        words_list = "\n".join([f"â€¢ {word}" for word in banned_words[chat_id]])
        await message.reply_text(f"ğŸ“œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø©:\n{words_list}")
    else:
        await message.reply_text("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒÙ„Ù…Ø§Øª Ù…Ù…Ù†ÙˆØ¹Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")

@app.on_message(filters.group & filters.text, group=33)
async def process_word_input(client, message):
    user_id = message.from_user.id
    if user_id in waiting_for_word:
        chat_id = waiting_for_word[user_id]["chat_id"]
        word = message.text.strip().lower()
        
        # Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒÙ„Ù…Ø© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø·Ù„Ø¨
        if waiting_for_word[user_id]["type"] == "ban":
            # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
            if str(chat_id) not in banned_words:
                banned_words[str(chat_id)] = []
            
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ„Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„
            if word not in banned_words[str(chat_id)]:
                banned_words[str(chat_id)].append(word)
                await message.reply_text(f"âœ… ØªÙ… Ù…Ù†Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø©: {word}\nØ³ÙŠØªÙ… Ø­Ø°ÙÙ‡Ø§ Ø¥Ø°Ø§ ØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡")
            else:
                await message.reply_text("âš ï¸ Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ù…Ù†ÙˆØ¹Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
        else:
            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
            if str(chat_id) in banned_words and word in banned_words[str(chat_id)]:
                banned_words[str(chat_id)].remove(word)
                await message.reply_text(f"âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ù…Ù†Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø©: {word}")
            else:
                await message.reply_text("âš ï¸ Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø© ØºÙŠØ± Ù…Ù…Ù†ÙˆØ¹Ø© Ø£ØµÙ„Ø§Ù‹!")
        
        # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        del waiting_for_word[user_id]
    else:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù…Ù†ÙˆØ¹Ø© Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        await check_banned_words(client, message)




async def check_banned_words(client, message):
    if not message.text:
        return
    
    chat_id = str(message.chat.id)
    if chat_id in banned_words and banned_words[chat_id]:
        message_text = message.text.lower()
        user_id = message.from_user.id
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        try:
            member = await client.get_chat_member(chat_id, user_id)
            if (member.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or
                is_owner(None, None, message) or
                is_moteerr(user_id) or
                is_mutaw(user_id) or
                is_malkeen(user_id) or
                is_admann(user_id)):
                return  # Ù„Ø§ ØªÙ‚Ù… Ø¨Ø£ÙŠ Ø´ÙŠØ¡ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±ØªØ¨ Ø§Ù„Ø¹Ù„ÙŠØ§
        except Exception as e:
            print(f"Error getting chat member: {e}")
            return
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£ÙŠ ÙƒÙ„Ù…Ø© Ù…Ù…Ù†ÙˆØ¹Ø© ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        for word in banned_words[chat_id]:
            if word in message_text:
                # Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ Ø§Ø­ØªÙˆØª Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø© Ù…Ù…Ù†ÙˆØ¹Ø©
                try:
                    await message.delete()
                    await client.send_message(
                        chat_id=message.chat.id,
                        text=f"ã€Œ  {message.from_user.mention}  ã€\nÙ‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ù…Ù†ÙˆØ¹Ø©!\nà¼„",
                        reply_to_message_id=message.id
                    )
                except Exception as e:
                    print(f"Error deleting message: {e}")
                break


@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±", "") & filters.group, group=27)
async def lock_repeat(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):    
        if not locks.repeat_locked:
            locks.repeat_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªÙƒØ±Ø§Ø±\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØªÙƒØ±Ø§Ø± Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØªÙƒØ±Ø§Ø±", "") & filters.group, group=27)
async def unlock_repeat(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if locks.repeat_locked:
            locks.repeat_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªÙƒØ±Ø§Ø±\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØªÙƒØ±Ø§Ø± Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

# Ù…ØªØºÙŠØ±Ø§Øª Ù„ØªØªØ¨Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
user_message_history = {}  # {chat_id: {user_id: [messages]}}

async def check_repeat(chat_id, user_id, text):
    # ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ§Ø±ÙŠØ® Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
    if chat_id not in user_message_history:
        user_message_history[chat_id] = {}
    if user_id not in user_message_history[chat_id]:
        user_message_history[chat_id][user_id] = []
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    user_message_history[chat_id][user_id].append(text)
    
    # Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¢Ø®Ø± 5 Ø±Ø³Ø§Ø¦Ù„ ÙÙ‚Ø·
    if len(user_message_history[chat_id][user_id]) > 5:
        user_message_history[chat_id][user_id] = user_message_history[chat_id][user_id][-5:]
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
    if len(user_message_history[chat_id][user_id]) >= 3:
        last_three = user_message_history[chat_id][user_id][-3:]
        if all(msg == text for msg in last_three):
            return True
    return False

@app.on_message(filters.group & ~filters.service, group=32)
async def handle_repeat(client, message):
    try:
        if not message.from_user or not message.text:
            return
            
        chat_id = message.chat.id
        user_id = message.from_user.id
        locks = get_chat_locks(chat_id)
        
        if locks.repeat_locked:
            member = await client.get_chat_member(chat_id, user_id)
            if not (member.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or
                   is_owner(None, None, message) or
                   is_moteerr(user_id) or
                   is_mutaw(user_id) or
                   is_malkeen(user_id) or
                   is_admann(user_id)):
                
                is_repeated = await check_repeat(chat_id, user_id, message.text)
                if is_repeated:
                    await message.delete()
                    warning_msg = await client.send_message(
                        chat_id=chat_id,
                        text=f"ã€Œ  {message.from_user.mention}  ã€\nÙ…Ù…Ù†ÙˆØ¹ ØªÙƒØ±Ø§Ø± Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù‡Ù†Ø§!\nà¼„"
                    )
                    
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±: {e}")

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª", "") & filters.group, group=25)
async def lock_bots(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if not locks.bots_locked:
            locks.bots_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø¨ÙˆØªØ§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø¨ÙˆØªØ§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø¨ÙˆØªØ§Øª", "") & filters.group, group=25)
async def unlock_bots(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if locks.bots_locked:
            locks.bots_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø¨ÙˆØªØ§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø¨ÙˆØªØ§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_chat_member_updated()
async def handle_new_bot(client, chat_member_updated):
    try:
        chat_id = chat_member_updated.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.bots_locked and chat_member_updated.new_chat_member.user.is_bot:
            # Ø·Ø±Ø¯ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¬Ø¯ÙŠØ¯
            await client.ban_chat_member(
                chat_id=chat_id,
                user_id=chat_member_updated.new_chat_member.user.id
            )
            await client.send_message(
                chat_id=chat_id,
                text=f"âŒ ØªÙ… Ø·Ø±Ø¯ Ø§Ù„Ø¨ÙˆØª [{chat_member_updated.new_chat_member.user.first_name}](tg://user?id={chat_member_updated.new_chat_member.user.id}) Ø¨Ø³Ø¨Ø¨ ØªÙØ¹ÙŠÙ„ Ù‚ÙÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª"
            )
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¬Ø¯ÙŠØ¯: {e}")


@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„", "") & filters.group, group=23)
async def lock_edit(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
        if not locks.edit_locked:
            locks.edit_locked = True
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù…Ù‚ÙÙ„ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„", "") & filters.group, group=23)
async def unlock_edit(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if locks.edit_locked:
            locks.edit_locked = False
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù…ÙØªÙˆØ­ Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_edited_message(filters.group, group=30)
async def handle_edited_messages(client, edited_message):
    try:
        chat_id = edited_message.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.edit_locked and edited_message.from_user:
            member = await client.get_chat_member(chat_id, edited_message.from_user.id)
            if not (member.status in [ChatMemberStatus.OWNER] or
                   is_owner(None, None, edited_message) or
                   is_moteerr(edited_message.from_user.id) or 
                   is_mutaw(edited_message.from_user.id) or
                   is_malkeen(edited_message.from_user.id) or
                   is_admann(edited_message.from_user.id)):
                await edited_message.delete()
                await client.send_message(
                    chat_id=chat_id,
                    text=f"ã€Œ  {edited_message.from_user.mention} ã€\n Ù…Ù…Ù†ÙˆØ¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù‡Ù†Ø§!\nà¼„"
                )
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©: {e}")



@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø§Ø´Ø¹Ø§Ø±Ø§Øª", "") & filters.group, group=31)
async def lock_notifications(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or
        is_moteerr(message.from_user.id) or  
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if not locks.notifications_locked:
            locks.notifications_locked = True
            await client.set_chat_permissions(
                chat_id=chat_id,
                permissions=ChatPermissions(
                    can_send_messages=True,
                    can_send_media_messages=True,
                    can_send_polls=True,
                    can_send_other_messages=True,
                    can_add_web_page_previews=True,
                    can_change_info=False,
                    can_invite_users=False,
                    can_pin_messages=False
                )
            )
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention} ã€\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§Ø´Ø¹Ø§Ø±Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø§Ø´Ø¹Ø§Ø±Ø§Øª", "") & filters.group, group=31)
async def unlock_notifications(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if locks.notifications_locked:
            locks.notifications_locked = False
            await client.set_chat_permissions(
                chat_id=chat_id,
                permissions=ChatPermissions(
                    can_send_messages=True,
                    can_send_media_messages=True,
                    can_send_polls=True,
                    can_send_other_messages=True,
                    can_add_web_page_previews=True,
                    can_change_info=True,
                    can_invite_users=True,
                    can_pin_messages=True
                )
            )
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§Ø´Ø¹Ø§Ø±Ø§Øª\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("Ù‚ÙÙ„ Ø§Ù„Ø§Ø¶Ø§ÙÙ‡", "") & filters.group, group=22)
async def lock_add(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if not locks.add_locked:
            locks.add_locked = True
            await client.set_chat_permissions(
                chat_id=chat_id,
                permissions=ChatPermissions(
                    can_invite_users=False
                )
            )
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± Ù‚ÙÙ„Øª Ø§Ù„Ø§Ø¶Ø§ÙÙ‡\nà¼„")
        else:
            await message.reply_text("ğŸ”’ Ø§Ù„Ø§Ø¶Ø§ÙÙ‡ Ù…Ù‚ÙÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command("ÙØªØ­ Ø§Ù„Ø§Ø¶Ø§ÙÙ‡", "") & filters.group, group=22)
async def unlock_add(client, message):
    chat_id = message.chat.id
    locks = get_chat_locks(chat_id)
    
    get = await client.get_chat_member(message.chat.id, message.from_user.id)
    if (get.status in [ChatMemberStatus.OWNER] or 
        is_owner(None, None, message) or 
        is_moteerr(message.from_user.id) or 
        is_mutaw(message.from_user.id) or 
        is_malkeen(message.from_user.id) or 
        is_admann(message.from_user.id)):
    
        if locks.add_locked:
            locks.add_locked = False
            await client.set_chat_permissions(
                chat_id=chat_id,
                permissions=ChatPermissions(
                    can_invite_users=True
                )
            )
            await message.reply_text(f"â‡œÙ…Ù†ã€Œ  {message.from_user.mention}\nâ‡œØ§Ø¨Ø´Ø± ÙØªØ­Øª Ø§Ù„Ø§Ø¶Ø§ÙÙ‡\nà¼„")
        else:
            await message.reply_text("ğŸ”“ Ø§Ù„Ø§Ø¶Ø§ÙÙ‡ Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„!")
    else:
        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_chat_member_updated()
async def handle_new_member(client, chat_member_updated):
    try:
        chat_id = chat_member_updated.chat.id
        locks = get_chat_locks(chat_id)
        
        if locks.add_locked and chat_member_updated.new_chat_member:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¨ÙˆØ§Ø³Ø·Ø© Ø¹Ø¶Ùˆ Ø¹Ø§Ø¯ÙŠ ÙˆÙ„ÙŠØ³ Ø£Ø¯Ù…Ù† Ø£Ùˆ Ù…Ø§Ù„Ùƒ
            adder = chat_member_updated.invited_by
            if adder:
                member = await client.get_chat_member(chat_id, adder.id)
                if not (member.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or
                       is_owner(None, None, chat_member_updated) or
                       is_moteerr(adder.id) or 
                       is_mutaw(adder.id) or
                       is_malkeen(adder.id) or
                       is_admann(adder.id)):
                    # Ø·Ø±Ø¯ Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ù…Ø¶Ø§Ù
                    await client.ban_chat_member(
                        chat_id=chat_id,
                        user_id=chat_member_updated.new_chat_member.user.id
                    )
                    # Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø°ÙŠØ±
                    await client.send_message(
                        chat_id=chat_id,
                        text=f"âŒ ØªÙ… Ø·Ø±Ø¯ {chat_member_updated.new_chat_member.user.mention} Ø¨Ø³Ø¨Ø¨ Ù‚ÙÙ„ Ø§Ù„Ø¥Ø¶Ø§ÙØ©\nØ§Ù„Ù…Ø¶ÙŠÙ: {adder.mention}"
                    )
    except Exception as e:
        print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯: {e}")




     