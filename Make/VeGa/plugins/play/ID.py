import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGa import app
from pytz import timezone
import datetime
from pytz import timezone
from pyrogram import enums
import aiohttp
import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGa.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup

import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGa import app as Hiroko 

from PIL import (Image, ImageDraw, ImageEnhance, ImageFilter,
                 ImageFont, ImageOps)
import asyncio
import os
import random
import re
import textwrap
import aiofiles
import aiohttp
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter, ImageFont, ImageOps
from youtubesearchpython.__future__ import VideosSearch
import numpy as np

from config import YOUTUBE_IMG_URL


import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGa import app
from config import *
import config
from VeGa import  app
from config import OWNER_ID
from pytz import timezone
from pyrogram import enums
import aiohttp

import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGa.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup



from datetime import datetime
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup


import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGa import app as Hiroko 

# Function to get font and resize text



import requests
from PIL import Image
import os






import asyncio
import os
import random
import re
import textwrap
import aiofiles
import aiohttp
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter, ImageFont, ImageOps
from youtubesearchpython.__future__ import VideosSearch
import numpy as np

from config import YOUTUBE_IMG_URL


import asyncio
import os
import time
import requests
import datetime
import random
import os
import time
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram import enums, filters
from VeGa import app

from pytz import timezone
from pyrogram import enums
import aiohttp
import datetime
from pytz import timezone
from pyrogram import filters
from pyrogram import Client
from typing import Union
from random import choice
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from VeGa.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from telegraph import upload_file
from asyncio import gather
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
import asyncio
from PIL import Image, ImageDraw, ImageFont
from pyrogram import filters, Client, enums
from pyrogram.types import *
from typing import Union, Optional
from VeGa import app as Hiroko 

# Function to get font and resize text



import requests
from PIL import Image
import os

import asyncio
import re
import time
import requests
import aiohttp
import time
import asyncio
from pyrogram import Client, filters
from pyrogram import filters
from datetime import datetime
from pyrogram import enums
from VeGa.misc import SUDOERS
from config import OWNER_ID
from config import BANNED_USERS
from config import BANNED_USERS, OWNER_ID
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.types import CallbackQuery, InputMediaPhoto, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatType, ChatMemberStatus
from pyrogram.enums import ChatMemberStatus, ParseMode
from VeGa import app
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import *
from pyrogram.enums import ChatMembersFilter
from telegraph import upload_file
from asyncio import gather
from pyrogram.enums import ChatMembersFilter
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import ChatPermissions, ChatPrivileges
from config import *
from pyrogram.enums import ChatMembersFilter
import asyncio

from pyrogram.enums import ParseMode

from VeGa import app
from VeGa.utils.database import is_on_off
from config import LOGGER_ID


from pyrogram import filters
from pyrogram import Client
from VeGa.core.call import KIM
from pyrogram.enums import ChatMemberStatus
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from VeGa import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
from VeGa import app
from telegraph import upload_file
from asyncio import gather

import random
from VeGa.misc import SUDOERS
from pyrogram.types import (Message,InlineKeyboardButton,InlineKeyboardMarkup,CallbackQuery,ChatPrivileges)
from pyrogram import filters, Client
from VeGa import app
from config import *



def is_owner(_, __, message):
    if not message or not message.from_user:
        return False
    return message.from_user.id in [OWNER_ID, 7654641648, 1121532100]

async def is_admin(message):
    try:
        if not message or not message.from_user:
            return False
            
        user = message.from_user
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø§Ù„Ùƒ Ø£Ùˆ Ù…Ø·ÙˆØ± Ù…Ø¹ØªÙ…Ø¯
        if user.id in [OWNER_ID, 7654641648, 1121532100]:
            return True
            
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø´Ø±Ù ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        if not message.chat:
            return False
            
        member = await message.chat.get_member(user.id)
        return member.status in [
            enums.ChatMemberStatus.OWNER,
            enums.ChatMemberStatus.ADMINISTRATOR
        ]
        
    except Exception as e:
        print(f"Error in is_admin check: {e}")
        return False




@app.on_message(filters.command(["ÙØ­Øµ Ø§Ù„Ø¬Ø±ÙˆØ¨"], ""), group=26777)
async def instatus(Client, message):
    start_time = time.perf_counter()
    user = await app.get_chat_member(message.chat.id, message.from_user.id)
    count = await app.get_chat_members_count(message.chat.id)
    get = await app.get_chat_member(message.chat.id, message.from_user.id)
    if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR] or message.from_user.id == OWNER_ID or message.from_user.id == 7654641648:
        chat_idd = message.chat.id
        chat_name = message.chat.title
        chat_username = f"@{message.chat.username}"
        deleted_acc = 0
        premium_acc = 0
        banned = 0
        bot = 0
        uncached = 0
        async for ban in app.get_chat_members(message.chat.id, filter=enums.ChatMembersFilter.BANNED):
            banned += 1
        async for member in app.get_chat_members(message.chat.id):
            user = member.user
            if user.is_deleted:
                deleted_acc += 1
            elif user.is_bot:
                bot += 1
            elif user.is_premium:
                premium_acc += 1
            else:
                uncached += 1
        end_time = time.perf_counter()
        timelog = "{:.2f}".format(end_time - start_time)
        if message.chat.photo:
             photo = await app.download_media(message.chat.photo.big_file_id)
             
             await message.reply_photo(photo=photo,  caption=f"""<blockquote><b>Â»â­“É¢ê›á´á´œá´˜ âœ˜ ÉªÉ´êœ°á´ê›á´á´§á´›Éªá´É´â™ª</blockquote>

<blockquote>â•®â—‰   Ø§Ù„Ø§Ø³Ù… : {message.chat.title} 
â”ƒášœâ—‰  ÙŠÙˆØ²Ø± : @{message.chat.username}
â•¯â—‰   Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ :  {count} 

â•®â—‰   Ø§Ù„Ø¨ÙˆØªØ§Øª : {bot}
â”ƒášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙÙ‡ : {deleted_acc}
â”ƒášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø­Ø¸ÙˆØ±Ù‡ : {banned}
â•¯â—‰   Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ«Ù‚Ø© : {premium_acc}</b></blockquote>""",
         reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        chat_name, url=f"https://t.me/{message.chat.username}")
                         
                ],
            ]
        ),
    )
        else:
             await message.reply_text(f"""<blockquote><b>Â»â­“É¢ê›á´á´œá´˜ âœ˜ ÉªÉ´êœ°á´ê›á´á´§á´›Éªá´É´â™ª</blockquote>\nâ•®â—‰  Ø§Ù„Ø§Ø³Ù… : {message.chat.title}\nâ”ƒášœâ—‰ ÙŠÙˆØ²Ø± : @{message.chat.username}\nâ•¯â—‰  Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ :  {count} \nâ•®â—‰  Ø§Ù„Ø¨ÙˆØªØ§Øª: {bot}\nâ”ƒášœâ—‰  Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø°ÙˆÙÙ‡ : {deleted_acc}\nâ”ƒášœâ—‰  Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: {banned}\nâ•¯â—‰  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø¨Ø±ÙŠÙ…ÙŠÙˆÙ…: {premium_acc}</b>""", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(chat_name, url=f"https://t.me/{message.chat.username}")],]))    
    else:
        sent_message = await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")
        await sleep(3)
        await sent_message.delete()








@app.on_message(filters.command(["Ø§Ù„Ù…Ø§Ù„Ùƒ", "ØµØ§Ø­Ø¨ Ø§Ù„Ø®Ø±Ø§Ø¨Ù‡", "Ø§Ù„Ù…Ù†Ø´ÙŠ"], ""), group=95)
async def ownner(client: Client, message: Message):
    try:
        owner = None
        async for member in client.get_chat_members(
            message.chat.id, 
            filter=enums.ChatMembersFilter.ADMINISTRATORS
        ):
            if member.status == ChatMemberStatus.OWNER:
                owner = member.user
                break

        if not owner:
            return await message.reply_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø§Ù„Ùƒ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
        username = f"@{owner.username}" if owner.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
        chat_title = message.chat.title or "Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…"
        
        caption = (
            f"<blockquote><b>"
            f"â•­â—‰  É´á´§á´á´‡ : {owner.first_name}\n"
            f"â”ƒášœâ—‰ á´œsá´‡ê› : {username}\n"
            f"â•°â—‰  Éªá´… : <code>{owner.id}</code>\n"
            f"â•­â—‰  á´„Êœá´§á´› : {chat_title}\n"
            f"â•°â—‰  Éªá´….á´„Êœá´§á´› : <code>{message.chat.id}</code>"
            f"</b></blockquote>"
        )

        # Ø²Ø± Ø§Ù„Ù…Ø§Ù„Ùƒ
        button = InlineKeyboardMarkup([
            [InlineKeyboardButton(owner.first_name, url=f"https://t.me/{owner.username}")] if owner.username else
            [InlineKeyboardButton(owner.first_name, callback_data="no_username")]
        ])

        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ù„Ù†Øµ
        if owner.photo:
            photos = [photo async for photo in client.get_chat_photos(owner.id, limit=1)]
            if photos:
                await message.reply_photo(
                    photo=photos[0].file_id,
                    caption=caption,
                    reply_markup=button,
                    has_spoiler=True  # ØªØ´ÙˆÙŠØ´ Ø§Ù„ØµÙˆØ±Ø©
                )
                return
        
        # Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø©
        await message.reply_text(
            caption,
            reply_markup=button
        )

    except Exception as e:
        print(f"Error in owner command: {e}")
        await message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ù„Ùƒ")



                          





@app.on_message(filters.command(["Ø§Ø³Ù…Ù‡", "Ø§Ø³Ù…Ùƒ"], ""), group=667558)
async def names4(client: Client, message: Message):
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ø³Ø§Ù„Ø© ØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡Ø§
    if not message.reply_to_message or not message.reply_to_message.from_user:
        return await message.reply_text("âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù…Ø¹Ø±ÙØ© Ø§Ø³Ù…Ù‡!")
    
    try:
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        replied_user = message.reply_to_message.from_user
        usr = await client.get_chat(replied_user.id)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø²Ø± Ø§Ù„Ø´Ø§Øª
        button = []
        if replied_user.username:
            button.append(
                [InlineKeyboardButton(
                    text=usr.first_name, 
                    url=f"https://t.me/{replied_user.username}"
                )]
            )
        
        await message.reply_text(
            f"""<blockquote><b>Ø§Ø³Ù… Ø§Ù„Ø§Ø±Ù†Ø¨</b> Â»Â» <code>{usr.first_name}</code></blockquote>""",
            reply_markup=InlineKeyboardMarkup(button) if button else None
        )
        
    except Exception as e:
        await message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")




@app.on_message(filters.command(["Ø§Ø³Ù…ÙŠ"], ""), group=6658)
async def vgdg(client: Client, message: Message):
    usr = await client.get_chat(message.from_user.id)
    name = usr.first_name
    await message.reply_text(
        f"""<blockquote><b> Ø¹Ø§Ø§Ø´Øª Ø§Ù„Ø§Ø³Ø§Ù…ÙŠ<b> Â»Â» <code>{message.from_user.mention}</code></blockquote>""",
    reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        message.from_user.first_name, url=f"https://t.me/{message.from_user.username}")
                ],
            ]
        )
    )


biof = []
@app.on_message(filters.command(["Ù‚ÙÙ„ Ø§Ù„Ø¨Ø§ÙŠÙˆ", "ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¨Ø§ÙŠÙˆ"], ""), group=509)
async def iddlock(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR]:
      if message.chat.id in biof:
        return await message.reply_text(" Ø­Ø¬ÙŠ Ø§Ù†Øª ØªÙ… Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„")
      biof.append(message.chat.id)
      return await message.reply_text(" ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¨Ø§ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")

@app.on_message(filters.command(["ÙØªØ­ Ø§Ù„Ø¨Ø§ÙŠÙˆ", "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨Ø§ÙŠÙˆ"], ""), group=678)
async def biopen(client, message):
   get = await client.get_chat_member(message.chat.id, message.from_user.id)
   if get.status in [ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR]:
      if not message.chat.id in biof:
        return await message.reply_text(" Ø­Ø¬ÙŠ Ø§Ù†Øª Ø§Ù„Ø¨Ø§ÙŠÙˆ Ù…ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ ")
      biof.remove(message.chat.id)
      return await message.reply_text("ØªÙ… ÙØªØ­  Ø§Ù„Ø¨Ø§ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­")
   else:
      return await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙŠØ®Øµ âª Ø§Ù„Ø§Ø¯Ù…Ù† ÙˆÙÙˆÙ‚ â« Ø¨Ø³")


@app.on_message(filters.command(["Ø¨Ø§ÙŠÙˆ", "Ø§Ù„Ø¨Ø§ÙŠÙˆ"], ""), group=444)
async def biio(client, message):
    if message.chat.id in biof:
        return 
    nq = await client.get_chat(message.from_user.id)
    bio = nq.bio if nq.bio else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø§ÙŠÙˆ Ù„Ù„Ø­Ø³Ø§Ø¨..ØŸ"
    await message.reply_text(bio)






 
#ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ± â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“
#ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ± â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

 
@app.on_message(filters.command(["ØªØ­ÙˆÙŠÙ„ Ù„ØµÙˆØ±Ù‡", "ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ù‡"], ""), group=555)
async def sticker_photo(client: Client, message: Message):
    reply = message.reply_to_message
    if not reply:
        return await message.reply("Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ù…Ù„ØµÙ‚.")
    if not reply.sticker:
        return await message.reply("Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ù…Ù„ØµÙ‚.")
    m = await message.reply("ÙŠØªÙ… Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ù‡..")
    f = await reply.download(f"{reply.sticker.file_unique_id}.png")
    await gather(*[message.reply_photo(f),message.reply_document(f)])
    await m.delete()
    os.remove(f)

    

#ØªØ­ÙˆÙŠÙ„ ØµÙˆØ±Ù‡ Ù„Ù…Ù„ØµÙ‚ â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“
#ØªØ­ÙˆÙŠÙ„ ØµÙˆØ±Ù‡ Ù„Ù…Ù„ØµÙ‚ â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

@app.on_message(filters.command(["Ø­ÙˆÙ„ Ù…Ù„ØµÙ‚"], ""), group=5267)
async def sticker_photo(client: Client, message: Message):
    reply = message.reply_to_message
    if not reply:
        return await message.reply("Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø©.")
    if not reply.photo:
        return await message.reply("Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø©.")
    m = await message.reply("ğŸ’£")
    photo = reply.photo.file_id
    file_path = await client.download_media(photo)
    await client.send_sticker(
        chat_id=message.chat.id,
        sticker=file_path
    )
    await m.delete()
    os.remove(file_path)





@app.on_message(filters.command(['Ø§Ø³ØªÙƒ'], prefixes=""), group=1282)
async def sticker_id(_, message: Message):
    reply = message.reply_to_message
    if not reply:
        return await message.reply("Ø¹Ø²ÙŠØ²ÙŠ Ù‚Ù… Ø¨Ø±Ø¯ Ø¹Ù„ÙŠ Ø§Ù„Ø§Ø³ØªÙŠÙƒØ±")
    if not reply.sticker:
        return await message.reply("Ø¹Ø²ÙŠØ²ÙŠ Ù‚Ù… Ø¨Ø±Ø¯ Ø¹Ù„ÙŠ Ø§Ù„Ø§Ø³ØªÙŠÙƒØ±")
    await message.reply_text(f"<code>{reply.sticker.file_id}</code>\n\n<b>Ø¹Ø²ÙŠØ²ÙŠ Ù‡Ø°Ø§ Ù‡Ùˆ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø§Ø³ØªÙŠÙƒØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:</b>")

